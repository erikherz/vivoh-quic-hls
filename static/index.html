<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <link rel="icon" href="data:;base64,=">
    <title>Vivoh WebTransport HLS Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .mainContainer {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .url-input {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .video-container {
            margin: 20px 0;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .video-logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100px;
            opacity: 0.8;
        }
        .centeredVideo {
            width: 100%;
            margin: 0 auto;
            display: block;
        }
        .logcatBox {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            background: #f8f9fa;
            height: 200px;
            overflow-y: auto;
            text-align: left;
            margin-top: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .btn {
            background-color: #1e88e5;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #1565c0;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"] {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            width: 80%;
            font-size: 16px;
        }
        label {
            font-weight: bold;
            white-space: nowrap;
        }
        .status-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-label {
            font-weight: bold;
        }
        .status-badge {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 14px;
        }
        .status-connected {
            background-color: #4caf50;
            color: white;
        }
        .status-disconnected {
            background-color: #f44336;
            color: white;
        }
        .status-buffering {
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <div class="mainContainer">
        <img src="vivoh.png" class="video-logo" alt="Video Logo">
        <div class="url-input">
            <label for="wtUrl">WebTransport URL:</label>
            <input id="wtUrl" type="text" value="https://va01.wtmpeg.com/live" style="width: 70%; padding: 10px;">
        </div>
        <div class="video-container">
            <video id="videoElement" class="centeredVideo" controls playsinline>
                Your browser is too old which doesn't support HTML5 video.
            </video>
        </div>
        <div class="status-container">
            <div class="status-indicator">
                <span class="status-label">Connection:</span>
                <span id="connectionStatus" class="status-badge status-disconnected">Disconnected</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">HLS Fragments:</span>
                <span id="bufferStatus" class="status-badge">0 fragments</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Player:</span>
                <span id="playerStatus" class="status-badge">Idle</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">QUIC Streams:</span>
                <span id="streamCounter" class="status-badge">0</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Media Packets:</span>
                <span id="packetCounter" class="status-badge">0</span>
            </div>
        </div>
        <div class="controls">
            <button id="connectButton" class="btn">Connect</button>
            <button id="playButton" class="btn" disabled>Play</button>
            <button id="disconnectButton" class="btn" disabled>Disconnect</button>
        </div>
        <textarea id="logcatbox" class="logcatBox" rows="10" readonly></textarea>
    </div>

    <script src="hls.js"></script>
    <script>


// Global variables
let transport = null;
let packetHandler = null;
let statusInterval = null;
let player = null;
let playerState = 'idle';
let disconnectionRequested = false;
let activeReaders = [];
let xhrInterceptionEnabled = false;
let streamCounter = 0;
let bufferLoggingIntervals = [];
window.blobUrlMap = new Map();
window.segmentBlobUrlMap = new Map();
let masterPlaylistUrl = null;
let videoPlaylistUrl = null;
let fragmentCounter = 0;
window.streamBuffers = [];
window.connectionStartTime = Date.now();

window.registerMediaSegment = (trackId, segmentId, data, segmentName) => {
    // Store with both the exact name and the ID-based key
    window.blobUrlMap.set(segmentName, data);
    window.blobUrlMap.set(`segment-${trackId}-${segmentId}`, data);
    log(`🔗 Registered segment: ${segmentName}`);
};

function startHlsPlayback(hlsUrl) {
    const video = document.getElementById('videoElement');
    if (!video) {
        log("❌ No video element found!");
        return;
    }

    if (Hls.isSupported()) {
        const hls = new Hls();
        hls.loadSource(hlsUrl);
        hls.attachMedia(video);
        hls.on(Hls.Events.MANIFEST_PARSED, function () {
            log('🎬 HLS manifest parsed, attempting autoplay...');
            video.play().catch(err => {
                log(`⚠️ Autoplay failed: ${err.message}`);
            });
        });
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = hlsUrl;
        video.addEventListener('loadedmetadata', function () {
            video.play().catch(err => {
                log(`⚠️ Autoplay failed: ${err.message}`);
            });
        });
    } else {
        log('❌ HLS not supported in this browser.');
    }
}

/**
 * WebTransportHLSPacketHandler class with support for fragmented packets
 * 
 * Processes incoming media data from WebTransport and makes it available for HLS.js
 * Enhanced to handle fragmented packets from WebTransport streams
 */
 class WebTransportHLSPacketHandler {
    constructor() {
        // Simplified buffer structure - just a map of segment IDs to data
        this.segments = {}; // Map of segmentId -> HLS segment data
        
        // Track metadata about fragments
        this.fragments = [];
        
        // HLS manifest content
        this.hlsData = null;
        this.hlsUrl = '/vivoh.m3u8';
        
        // Statistics and state
        this.bytesReceived = 0;
        this.fragmentsReceived = 0;
        this.packetsReceived = 0;
        this.lastProcessedPacketId = -1;
        this.isDisconnected = false;
        
        // Event callback
        this.onHLSReady = null;
        
        // Track partial packets being assembled
        this.partialPackets = {};
        
        // Enhanced stats
        this.partialPacketsReceived = 0;
        this.partialPacketsCompleted = 0;
        
        log("📦 WebTransport HLS Packet Handler with fragmentation support initialized");
    }
    
    /**
     * Process a validated packet directly
     */
    processValidatedPacket(packet) {
        // Check if this is a complete packet
        const isComplete = packet.avData && packet.avData.byteLength >= packet.avDataLen;
        
        if (isComplete) {
            // Process complete packet directly
            this._processCompletePacket(packet);
        } else {
            // Handle as a fragment for incomplete packets
            this.processPacketFragment(packet, false);
        }
    }
    
    /**
     * Process a complete packet that has all its data
     * @private
     */
    _processCompletePacket(packet) {
        // Update tracking stats
        this.lastProcessedPacketId = packet.packetId;
        this.packetsReceived++;
        
        // For MPEG-TS streams, process the data as an HLS segment
        if (packet.avData && packet.avData.byteLength > 0) {
            this._processHLSSegment(packet.packetId, packet.avData, packet.segmentDuration);
        }
        
        // Log periodic stats
        if (this.packetsReceived % 10 === 0) {
            const tsSeconds = Number(packet.timestamp) / 1000000; // Convert microseconds to seconds
            log(`📈 Packet stats: Received=${this.packetsReceived}, ID=${packet.packetId}, TS=${tsSeconds.toFixed(3)}s, Duration=${packet.duration}ms, SegDuration=${packet.segmentDuration}s, Segments=${Object.keys(this.segments).length}`);
        }
        
        // Update stats
        this.fragmentsReceived++;
        this.bytesReceived += packet.avData ? packet.avData.byteLength : 0;
        
        // Check if we have enough data to start playback
        this._checkPlaybackReadiness();
        
        // Generate manifest after receiving a few packets if we don't have one yet
        if (!this.hlsData && this.packetsReceived >= 3) {
            this._generateHLSManifest();
        }
    }
    
    /**
     * Process a partial packet fragment
     * @param {Object} packet - The packet object with header and partial data
     * @param {boolean} isComplete - Whether this is a complete packet
     * @returns {boolean} - Whether the packet was processed successfully
     */
    processPacketFragment(packet, isComplete = false) {
        // Increment counter
        this.partialPacketsReceived++;
        
        // Get the packet ID for tracking
        const packetId = packet.packetId;
        
        // If this is a new partial packet, initialize tracking
        if (!this.partialPackets[packetId]) {
            this.partialPackets[packetId] = {
                header: {
                    packetId: packet.packetId,
                    timestamp: packet.timestamp,
                    duration: packet.duration,
                    segmentDuration: packet.segmentDuration,
                    avDataLen: packet.avDataLen
                },
                fragments: [],
                bytesReceived: 0,
                totalSize: packet.avDataLen,
                isComplete: false,
                lastUpdated: Date.now()
            };
            
            log(`📦 Started tracking partial packet #${packetId} (expected size: ${packet.avDataLen} bytes)`);
        }
        
        // Add this fragment to the partial packet
        const partialPacket = this.partialPackets[packetId];
        partialPacket.fragments.push(packet.avData);
        partialPacket.bytesReceived += packet.avData.byteLength;
        partialPacket.lastUpdated = Date.now();
        
        // Log progress occasionally
        if (this.partialPacketsReceived % 5 === 0 || partialPacket.bytesReceived >= partialPacket.totalSize) {
            const percent = (partialPacket.bytesReceived / partialPacket.totalSize * 100).toFixed(1);
            log(`📊 Packet #${packetId} assembly: ${partialPacket.bytesReceived}/${partialPacket.totalSize} bytes (${percent}%)`);
        }
        
        // If fragment is complete or we've received all expected data, finalize the packet
        if (isComplete || partialPacket.bytesReceived >= partialPacket.totalSize) {
            // Mark as complete
            partialPacket.isComplete = true;
            this.partialPacketsCompleted++;
            
            // Assemble the complete packet by combining fragments
            const assembledData = new Uint8Array(partialPacket.bytesReceived);
            let offset = 0;
            
            for (const fragment of partialPacket.fragments) {
                assembledData.set(fragment, offset);
                offset += fragment.byteLength;
            }
            
            // Create a complete packet object
            const completePacket = {
                ...partialPacket.header,
                avData: assembledData
            };
            
            // Process using the main packet processing method
            this._processCompletePacket(completePacket);
            
            log(`✅ Completed packet #${packetId} (${partialPacket.bytesReceived} bytes) - processed successfully`);
            
            // Remove from tracking to free memory
            delete this.partialPackets[packetId];
            
            return true;
        }
        
        return false;
    }
    
    /**
     * Process packet fragments from stream data directly
     * This method allows processing smaller chunks without requiring the entire packet
     */
    processStreamChunk(streamId, chunk) {
        if (!chunk || chunk.byteLength < 24) {
            return false; // Too small to even contain a header
        }
        
        try {
            // Extract header fields from this chunk
            const view = new DataView(chunk.buffer, chunk.byteOffset, 24); // Fixed header size of 24 bytes
            
            const packetId = view.getUint32(0, false);         // Big endian
            const timestamp = view.getBigUint64(4, false);     // Big endian
            const duration = view.getUint32(12, false);
            const segmentDuration = view.getFloat32(16, false);
            const avDataLen = view.getUint32(20, false);
            
            // Basic validation
            if (!Number.isFinite(packetId) || packetId < 0 || packetId > 100000 ||
                !Number.isFinite(segmentDuration) || segmentDuration <= 0 || segmentDuration > 10 ||
                !Number.isFinite(avDataLen) || avDataLen <= 0 || avDataLen > 10 * 1024 * 1024) {
                return false; // Invalid header
            }
            
            // Create a packet object with the header data
            const packet = {
                packetId,
                timestamp,
                duration,
                segmentDuration,
                avDataLen,
                avData: chunk.slice(24) // Data portion (after header)
            };
            
            // Process this fragment
            this.processPacketFragment(packet, chunk.byteLength >= 24 + avDataLen);
            
            return true;
        } catch (error) {
            log(`❌ Error processing stream chunk from stream #${streamId}: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Process HLS data (e.g., from a manifest stream)
     */
     _processHLSData(data) {
        if (!data || data.byteLength === 0) return;
        
        try {
            // Convert the binary data to a string
            const hlsString = new TextDecoder().decode(data);
            
            // Check if this is an actual HLS manifest
            if (hlsString.includes('#EXTM3U')) {
                this.hlsData = hlsString;
                log(`📄 Extracted HLS manifest (${data.byteLength} bytes)`);
            } else {
                // If it's not a valid HLS manifest, we'll need to generate one
                log(`⚠️ MPD field doesn't contain a valid HLS manifest`);
                this._generateHLSManifest();
                return;
            }
            
            // Create a Blob URL for the HLS if needed
            if (typeof URL !== 'undefined' && URL.createObjectURL) {
                const blob = new Blob([this.hlsData], { type: 'application/vnd.apple.mpegurl' });
                this.hlsUrl = URL.createObjectURL(blob);
                log(`🔗 Created HLS blob URL: ${this.hlsUrl}`);
                
                // Register the HLS blob URL 
                if (typeof window.registerManifestBlobUrl === 'function') {
                    window.registerManifestBlobUrl(this.hlsUrl, this.hlsData);
                }
            }
            
            // Notify that the HLS is ready
            if (typeof this.onHLSReady === 'function') {
                this.onHLSReady(this.hlsUrl);
            }
        } catch (error) {
            log(`❌ Error processing HLS data: ${error.message}`);
        }
    }

    /**
     * Process an HLS segment 
     * - Simplified to handle multiplexed HLS segments
     */
    _processHLSSegment(segmentId, segmentData, segmentDuration = 1.0) {
        // Skip empty segments
        if (!segmentData || segmentData.byteLength === 0) {
            log(`⚠️ Empty segment data for #${segmentId}, skipping`);
            return;
        }
        
        // Validate size
        const MIN_SEGMENT_SIZE = 10 * 1024; // 10KB minimum
        if (segmentData.byteLength < MIN_SEGMENT_SIZE) {
            log(`⚠️ Segment #${segmentId} too small (${segmentData.byteLength} bytes < ${MIN_SEGMENT_SIZE}), may not be playable`);
            // Don't return, still process it for debugging
        }
        
        // Ensure segmentDuration is a valid number
        if (isNaN(segmentDuration) || !isFinite(segmentDuration) || segmentDuration <= 0) {
            // Default to 1.0 second if the duration is invalid
            segmentDuration = 1.0;
            log(`⚠️ Invalid segment duration for #${segmentId}, using default: 1.0`);
        }
        
        // Cap segment duration to reasonable values (between 0.1 and 10 seconds)
        segmentDuration = Math.max(0.1, Math.min(10.0, segmentDuration));
        
        // MPEG-TS detection - check for sync byte 0x47 ('G' in ASCII)
        const isMpegTs = segmentData.byteLength > 0 && segmentData[0] === 0x47;
        if (!isMpegTs) {
            log(`⚠️ Segment #${segmentId} is not valid MPEG-TS (no sync byte)`);
            // Don't return, still process it for debugging
        }
        
        // Generate the segment name
        const segmentName = `chunk-${segmentId.toString().padStart(5, '0')}.ts`;
        
        // Log detailed info about this segment
        log(`📦 HLS fragment #${segmentId} details:
        - Size: ${segmentData.byteLength} bytes
        - Duration: ${segmentDuration.toFixed(3)}s
        - Name: ${segmentName}
        - Valid MPEG-TS: ${isMpegTs ? "Yes" : "No"}`);
        
        // Store data in segments map
        // If we already have a segment with this ID, check if the new one is better
        if (this.segments[segmentId]) {
            const existing = this.segments[segmentId];
            
            // If existing is larger, keep it
            if (existing.byteLength > segmentData.byteLength) {
                log(`📦 Keeping existing larger segment #${segmentId} (${existing.byteLength} > ${segmentData.byteLength} bytes)`);
                return;
            }
            
            // If same size, check if existing is valid MPEG-TS
            if (existing.byteLength === segmentData.byteLength && existing[0] === 0x47 && segmentData[0] !== 0x47) {
                log(`📦 Keeping existing valid MPEG-TS segment #${segmentId}`);
                return;
            }
            
            log(`📦 Replacing segment #${segmentId} with better version (${existing.byteLength} → ${segmentData.byteLength} bytes)`);
        }
        
        // Store the segment
        this.segments[segmentId] = segmentData;
        
        // Add to fragments array with metadata
        this.fragments.push({
            sequence: segmentId,
            data: segmentData,
            timestamp: Date.now(),
            isMpegTs: isMpegTs,
            segmentDuration: segmentDuration,
            segmentName: segmentName
        });
        
        // Create and register blob URL
        const blob = new Blob([segmentData], { type: 'video/mp2t' });
        const blobUrl = URL.createObjectURL(blob);
        window.blobUrlMap.set(segmentName, segmentData);  // Store raw data
        window.segmentBlobUrlMap.set(segmentName, blobUrl);  // Store URL
        log(`✅ Registered segment: ${segmentName} (size: ${segmentData.byteLength} bytes)`);
        
        // Ensure blobUrlMap is defined
        if (!window.blobUrlMap) {
            window.blobUrlMap = new Map();
        }
        
        // Register the segment in all necessary maps
        window.blobUrlMap.set(segmentName, segmentData);
        
        // Make sure segmentBlobUrlMap is defined
        if (!window.segmentBlobUrlMap) {
            window.segmentBlobUrlMap = new Map();
        }
        window.segmentBlobUrlMap.set(segmentName, blobUrl);
        
        // Increment fragment counter
        window.fragmentCounter = (window.fragmentCounter || 0) + 1;
        
        // Update UI
        const bufferStatus = document.getElementById('bufferStatus');
        if (bufferStatus) {
            bufferStatus.textContent = `${window.fragmentCounter} fragments`;
        }
        
        // Keep the fragments array at a reasonable size (retain last 30 fragments)
        if (this.fragments.length > 30) {
            this.fragments = this.fragments.slice(-30);
        }
        
        // Update HLS manifest if needed
        this._updateHLSManifest();
    }
    
    /**
     * Generate HLS manifest from available segments
     */
    _generateHLSManifest() {
        // Create a basic master playlist
        let masterPlaylist = '#EXTM3U\n';
        masterPlaylist += '#EXT-X-VERSION:3\n';
        
        // Create a video media playlist using our improved generator
        let videoPlaylist = this._generateVideoPlaylist();
        
        // Log full video playlist content to both console and UI
        console.log("GENERATED VIDEO PLAYLIST:", videoPlaylist);
        log(`📄 VIDEO PLAYLIST CONTENT:\n${videoPlaylist}`);
        
        // Create blob URLs for the playlists
        const videoBlob = new Blob([videoPlaylist], { type: 'application/vnd.apple.mpegurl' });
        let videoPlaylistUrl = window.videoPlaylistUrl;
        
        if (!videoPlaylistUrl) {
            videoPlaylistUrl = URL.createObjectURL(videoBlob);
            window.videoPlaylistUrl = videoPlaylistUrl;
            log(`🔗 Created new video playlist URL: ${videoPlaylistUrl}`);
        } else {
            // Just update the map without changing URL
            log(`🔄 Updating existing video playlist URL: ${videoPlaylistUrl}`);
        }
        
        // Now reference the video playlist URL in the master playlist
        masterPlaylist += `#EXT-X-STREAM-INF:BANDWIDTH=3000000,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2"\n`;
        masterPlaylist += `${videoPlaylistUrl}\n`;
        
        // Log full master playlist content to both console and UI
        console.log("GENERATED MASTER PLAYLIST:", masterPlaylist);
        log(`📄 MASTER PLAYLIST CONTENT:\n${masterPlaylist}`);
        
        // Create blob URL for master playlist
        const masterBlob = new Blob([masterPlaylist], { type: 'application/vnd.apple.mpegurl' });
        let masterPlaylistUrl = window.masterPlaylistUrl;
        
        if (!masterPlaylistUrl) {
            masterPlaylistUrl = URL.createObjectURL(masterBlob);
            window.masterPlaylistUrl = masterPlaylistUrl;
            this.hlsUrl = masterPlaylistUrl;
            log(`🔗 Created new master playlist URL: ${masterPlaylistUrl}`);
        } else {
            // Just update the map without changing URL
            this.hlsUrl = masterPlaylistUrl;
            log(`🔄 Updating existing master playlist URL: ${masterPlaylistUrl}`);
        }
        
        // Make sure blobUrlMap is defined globally
        if (!window.blobUrlMap) {
            window.blobUrlMap = new Map();
        }
        
        // Register all playlists for XHR interception
        window.blobUrlMap.set(this.hlsUrl, masterPlaylist);
        window.blobUrlMap.set(videoPlaylistUrl, videoPlaylist);
        
        // Also use the registerManifestBlobUrl function if available
        if (typeof window.registerManifestBlobUrl === 'function') {
            window.registerManifestBlobUrl(this.hlsUrl, masterPlaylist);
            window.registerManifestBlobUrl(videoPlaylistUrl, videoPlaylist);
        }
        
        log(`✅ Generated HLS manifests and registered blob URLs: Master=${this.hlsUrl}, Video=${videoPlaylistUrl}`);
        
        // Notify that the HLS is ready
        if (typeof this.onHLSReady === 'function') {
            this.onHLSReady(this.hlsUrl);
        }

        // Try to start playback
        if (typeof startHlsPlayback === 'function') {
            startHlsPlayback(this.hlsUrl);
        }
        log(`🔍 MASTER PLAYLIST CONTENT: ${masterPlaylist}`);
        log(`🔍 VIDEO PLAYLIST CONTENT: ${videoPlaylist}`);
    }

    /**
     * Update the HLS manifest with new segments
     */
    _updateHLSManifest() {
        // Only update occasionally to avoid excessive regeneration
        if (Math.random() > 0.2) return; // Only update ~20% of the time
        
        // Generate new manifests with updated segment lists
        this._generateHLSManifest();
        log(`🔄 Updated HLS manifests with new fragments`);
    }

    /**
     * Generate the video playlist with available segments
     */
    _generateVideoPlaylist() {
        // Constants for validation
        const MIN_SEGMENT_SIZE = 50 * 1024; // 50 KB minimum size
        const MAX_SEGMENT_ID = 100000;      // Maximum reasonable segment ID
        const MAX_ALLOWED_GAP = 5;          // Maximum allowed gap in sequence

        // Create the basic playlist structure
        let videoPlaylist = '#EXTM3U\n';
        videoPlaylist += '#EXT-X-VERSION:3\n';
        videoPlaylist += '#EXT-X-TARGETDURATION:4\n';
        videoPlaylist += '#EXT-X-MEDIA-SEQUENCE:0\n';

        // Get all segments, filter and sort them
        const segmentIds = Object.keys(this.segments)
            .map(Number)
            .filter(id => {
                // Basic validation
                if (!Number.isFinite(id) || id < 0 || id > MAX_SEGMENT_ID) {
                    log(`⚠️ Filtering out invalid segment ID: ${id}`);
                    return false;
                }
                
                // Size validation
                const segment = this.segments[id];
                if (!segment || !segment.byteLength || segment.byteLength < MIN_SEGMENT_SIZE) {
                    log(`⚠️ Filtering out small segment #${id} (size=${segment?.byteLength || 0})`);
                    return false;
                }
                
                return true;
            })
            .sort((a, b) => a - b);

        // Handle empty case
        if (segmentIds.length === 0) {
            videoPlaylist += '#EXTINF:4.0,\n';
            videoPlaylist += 'chunk-00000.ts\n';
            
            // Register with our manifest blob map
            if (typeof window.registerManifestBlobUrl === 'function') {
                window.registerManifestBlobUrl('video.m3u8', videoPlaylist);
            }
            
            return videoPlaylist;
        }

        // Process segments with sequence validation
        let includedCount = 0;
        let lastIncludedId = null;

        for (let i = 0; i < segmentIds.length; i++) {
            const segId = segmentIds[i];
            const segment = this.segments[segId];
            
            // Skip non-sequential segments (prevent large gaps)
            if (lastIncludedId !== null && (segId - lastIncludedId) > MAX_ALLOWED_GAP) {
                log(`⚠️ Skipping out-of-sequence segment #${segId} (last was #${lastIncludedId})`);
                continue;
            }
            
            // Find segment duration from fragments if available
            let segmentDuration = 4.0; // Default
            const segmentInfo = this.fragments.find(f => f.sequence === segId);
            
            if (segmentInfo && Number.isFinite(segmentInfo.segmentDuration) && 
                segmentInfo.segmentDuration > 0 && segmentInfo.segmentDuration <= 10) {
                segmentDuration = segmentInfo.segmentDuration;
            }

            // Add segment to playlist with proper formatting
            videoPlaylist += `#EXTINF:${segmentDuration.toFixed(3)},\n`;
            const segmentName = `chunk-${segId.toString().padStart(5, '0')}.ts`;
            videoPlaylist += `${segmentName}\n`;

            lastIncludedId = segId;
            includedCount++;
        }

        // Add end list marker if disconnected
        if (this.isDisconnected) {
            videoPlaylist += '#EXT-X-ENDLIST\n';
        }

        // Register with our manifest blob map
        if (typeof window.registerManifestBlobUrl === 'function') {
            window.registerManifestBlobUrl('video.m3u8', videoPlaylist);
        }
        
        log(`📄 Generated video playlist with ${includedCount} valid segments`);
        return videoPlaylist;
    }
    
    /**
     * Check if we have enough data to start playback
     */
    _checkPlaybackReadiness() {
        // If player already exists, don't create another one
        if (window.player) {
            return;
        }
        
        // Check if we have HLS data or enough fragments to generate it
        const hasHLS = this.hlsData !== null;
        
        // Check if we have enough fragments
        const segmentCount = Object.keys(this.segments).length;
        
        // Wait until we have enough data to start playback
        if (hasHLS && segmentCount >= 3) {
            log(`✅ Media ready: HLS=${hasHLS}, Segments=${segmentCount}`);
            
            // Notify that we're ready to initialize the player
            if (typeof this.onHLSReady === 'function') {
                this.onHLSReady(this.hlsUrl);
            }
        } else if (!hasHLS && segmentCount >= 3) {
            // We have enough fragments but no HLS manifest - generate one
            this._generateHLSManifest();
        }
    }

    /**
     * Get a segment by ID
     */
    getSegment(segmentId) {
        // Try to find exact segment ID
        if (this.segments[segmentId]) {
            return this.segments[segmentId];
        }
        
        // If not found, get closest segment ID
        const keys = Object.keys(this.segments).map(Number).sort((a, b) => a - b);
        
        // Find closest segment (prefer newer segments)
        if (keys.length > 0) {
            // Sort by closeness to the requested segment ID
            keys.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId));
            const closestId = keys[0];
            
            log(`⚠️ Segment #${segmentId} not found, using closest #${closestId}`);
            return this.segments[closestId];
        }
        
        return null;
    }

    /**
     * Get stats about the received media
     */
    getStats() {
        const segmentCount = Object.keys(this.segments).length;
        
        return {
            bytesReceived: this.bytesReceived,
            fragments: this.fragments.length,
            segmentsAvailable: segmentCount,
            fragmentsReceived: this.fragmentsReceived,
            packetsReceived: this.packetsReceived,
            hlsAvailable: this.hlsData !== null,
            partialPackets: Object.keys(this.partialPackets).length,
            partialPacketsReceived: this.partialPacketsReceived,
            partialPacketsCompleted: this.partialPacketsCompleted
        };
    }
    
    /**
     * Get detailed statistics about partial packets
     */
    getPartialStats() {
        return {
            activePartials: Object.keys(this.partialPackets).length,
            totalPartialPackets: this.partialPacketsReceived,
            completedPartialPackets: this.partialPacketsCompleted
        };
    }
    
    /**
     * Periodic maintenance to check partial packet status
     */
    checkPartialPackets() {
        const now = Date.now();
        const staleTimeout = 30000; // 30 seconds
        
        for (const [packetId, partial] of Object.entries(this.partialPackets)) {
            // Check if this partial packet is stale
            if (now - partial.lastUpdated > staleTimeout) {
                // If we have enough data, try to process it anyway
                if (partial.bytesReceived > partial.totalSize * 0.9) {
                    log(`⚠️ Processing stale partial packet #${packetId} with ${partial.bytesReceived}/${partial.totalSize} bytes (${(partial.bytesReceived/partial.totalSize*100).toFixed(1)}%)`);
                    
                    // Force process as complete
                    this.processPacketFragment({
                        ...partial.header,
                        avData: partial.fragments[0] // Just use first fragment as example
                    }, true);
                } else {
                    // Remove stale data
                    log(`🧹 Removing stale partial packet #${packetId} (${partial.bytesReceived}/${partial.totalSize} bytes, age: ${((now - partial.lastUpdated)/1000).toFixed(1)}s)`);
                    delete this.partialPackets[packetId];
                }
            }
        }
    }

    /**
     * Disconnect and clean up resources
     */
    disconnect() {
        this.isDisconnected = true;
        log(`🧹 Cleaning up packet handler resources`);
        
        // Clear segments
        this.segments = {};
        
        // Clear fragments
        this.fragments = [];
        
        // Clean up partial packets
        this.partialPackets = {};
        
        // Clean up all blob URLs
        if (window.masterPlaylistUrl) {
            try {
                URL.revokeObjectURL(window.masterPlaylistUrl);
                log(`🧹 Revoked master playlist URL: ${window.masterPlaylistUrl}`);
                window.masterPlaylistUrl = null;
            } catch (e) {
                log(`⚠️ Error revoking master playlist URL: ${e.message}`);
            }
        }
        
        if (window.videoPlaylistUrl) {
            try {
                URL.revokeObjectURL(window.videoPlaylistUrl);
                log(`🧹 Revoked video playlist URL: ${window.videoPlaylistUrl}`);
                window.videoPlaylistUrl = null;
            } catch (e) {
                log(`⚠️ Error revoking video playlist URL: ${e.message}`);
            }
        }
        
        // Revoke segment blob URLs
        if (window.segmentBlobUrlMap) {
            for (const [name, blobUrl] of window.segmentBlobUrlMap.entries()) {
                try {
                    URL.revokeObjectURL(blobUrl);
                    log(`🧹 Revoked segment blob URL: ${name}`);
                } catch (e) {
                    log(`⚠️ Error revoking segment URL "${name}": ${e.message}`);
                }
            }
            window.segmentBlobUrlMap.clear();
        }
        
        // Clear HLS data
        this.hlsData = null;
        this.hlsUrl = '/vivoh.m3u8';
    }
}

/**
 * Enhanced WebTransportStreamBuffer with added debugging and improved packet detection
 */
 class WebTransportStreamBuffer {
    constructor(streamId) {
        // Buffer for accumulating partial data from this specific stream
        this.buffer = new Uint8Array(0);
        this.streamId = streamId;
        
        // Packet validation constants
        this.HEADER_SIZE = 24;
        this.MAX_PACKET_SIZE = 10 * 1024 * 1024; // 10MB max packet size
        this.MIN_SEGMENT_SIZE = 10 * 1024; // 10KB minimum segment size
        this.MAX_VALID_PACKET_ID = 100000; // Reasonable upper limit
        
        // Statistics
        this.totalBytesReceived = 0;
        this.validPacketsExtracted = 0;
        this.invalidPacketsRejected = 0;
        
        // Debugging: log first chunk contents
        this.hasLoggedFirstChunk = false;
    }
    
    /**
     * Add new data from WebTransport stream to the buffer
     * @param {Uint8Array|ArrayBuffer} chunk - New data chunk from WebTransport
     * @return {number} - Number of complete packets ready for processing
     */
    addChunk(chunk) {
        // Convert to Uint8Array if needed
        const data = (chunk instanceof ArrayBuffer) ? new Uint8Array(chunk) : chunk;
        
        // Debug: Log first chunk contents in detail to understand the format
        if (!this.hasLoggedFirstChunk && data.byteLength > 0) {
            // Log the first 32 bytes (or fewer if not available)
            const bytesToLog = Math.min(32, data.byteLength);
            const hexDump = Array.from(data.slice(0, bytesToLog))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
                
            // Also try to interpret as text for debugging
            let textView = '';
            try {
                textView = new TextDecoder().decode(data.slice(0, bytesToLog));
                // Replace non-printable characters with dots
                textView = textView.replace(/[^\x20-\x7E]/g, '.');
            } catch (e) {
                textView = '(not text)';
            }
            
            log(`🔍 Stream ${this.streamId} first chunk contents (${bytesToLog} bytes):`);
            log(`🔍 HEX: ${hexDump}`);
            log(`🔍 TXT: ${textView}`);
            
            // Check if this might be a text protocol (HTTP/WebSocket handshake, etc.)
            if (textView.includes('HTTP') || textView.includes('GET') || 
                textView.includes('POST') || textView.includes('WebSocket')) {
                log(`⚠️ Stream ${this.streamId} appears to contain text protocol data rather than binary media packets`);
            }
            
            this.hasLoggedFirstChunk = true;
        }
        
        // Update statistics
        this.totalBytesReceived += data.byteLength;
        
        // Append to existing buffer
        this.buffer = this._concatArrays(this.buffer, data);
        
        // Log diagnostic info occasionally
        if (this.totalBytesReceived % (1024 * 1024) === 0) { // Every 1MB
            const preview = Array.from(data.slice(0, Math.min(8, data.byteLength)))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
            
            log(`Stream ${this.streamId}: Received ${this.totalBytesReceived} bytes total. Latest chunk: ${data.byteLength} bytes starting with ${preview}`);
        }
        
        // Check if we have any complete packets available
        return this._countCompletePackets();
    }
    
    /**
     * Extract a complete packet if available - Enhanced with better debugging and packet scanning
     * @return {Object|null} - The extracted packet or null if none available
     */
    extractPacket() {
        // Check if buffer is large enough for header
        if (this.buffer.byteLength < this.HEADER_SIZE) {
            return null; // Not enough data for even the header
        }

        // Log buffer details once when it gets big enough
        if (this.buffer.byteLength >= this.HEADER_SIZE && !this.hasLoggedBufferHeader) {
            const headerHex = Array.from(this.buffer.slice(0, this.HEADER_SIZE))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
            log(`🔍 Stream ${this.streamId} header bytes: ${headerHex}`);
            this.hasLoggedBufferHeader = true;
        }

        const view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.HEADER_SIZE);
        
        // Parse header fields with validation and detailed logging
        try {
            const packetId = view.getUint32(0, false);         // Big endian
            const timestamp = view.getBigUint64(4, false);     // Big endian
            const duration = view.getUint32(12, false);
            const segmentDuration = view.getFloat32(16, false);
            const avDataLen = view.getUint32(20, false);

            // Log header fields for debugging (only once)
            if (!this.hasLoggedHeaderParsing) {
                log(`🔍 Stream ${this.streamId} parsed header: ID=${packetId}, TS=${timestamp}, duration=${duration}, segDuration=${segmentDuration}, avDataLen=${avDataLen}`);
                this.hasLoggedHeaderParsing = true;
            }

            // Enhanced validation with specific error messages
            if (!Number.isFinite(packetId) || packetId < 0 || packetId > this.MAX_VALID_PACKET_ID) {
                log(`🚨 Invalid packet ID: ${packetId} (must be 0-${this.MAX_VALID_PACKET_ID})`);
                this.buffer = this.buffer.slice(1); // Skip one byte and try again
                this.invalidPacketsRejected++;
                return null;
            }
            
            if (!Number.isFinite(segmentDuration) || segmentDuration <= 0 || segmentDuration > 10) {
                log(`🚨 Invalid segment duration: ${segmentDuration}s (must be 0-10s)`);
                this.buffer = this.buffer.slice(1);
                this.invalidPacketsRejected++;
                return null;
            }
            
            if (!Number.isFinite(avDataLen) || avDataLen <= 0 || avDataLen > this.MAX_PACKET_SIZE) {
                log(`🚨 Invalid data length: ${avDataLen} (must be 1-${this.MAX_PACKET_SIZE})`);
                this.buffer = this.buffer.slice(1);
                this.invalidPacketsRejected++;
                return null;
            }

            const totalSize = this.HEADER_SIZE + avDataLen;

            // Check if we have enough data for the complete packet
            if (this.buffer.byteLength < totalSize) {
                // Not enough data yet, wait for more
                if (!this.hasLoggedWaitingForData) {
                    log(`🔍 Stream ${this.streamId} waiting for more data: have ${this.buffer.byteLength}, need ${totalSize} bytes`);
                    this.hasLoggedWaitingForData = true;
                }
                return null;
            }

            // Sync byte check (first byte of MPEG-TS should be 0x47)
            const syncByte = this.buffer[this.HEADER_SIZE];
            if (syncByte !== 0x47) {
                log(`🚨 Invalid MPEG-TS sync byte. Expected 0x47, got 0x${syncByte.toString(16)}. Discarding byte to resync.`);
                
                // ENHANCED: Perform a scan for valid sync pattern
                const scanResult = this._scanForSyncPattern();
                if (scanResult > 0) {
                    log(`🔍 Found potential sync pattern at offset ${scanResult}, skipping ahead`);
                    this.buffer = this.buffer.slice(scanResult);
                } else {
                    // Just skip one byte if no pattern found
                    this.buffer = this.buffer.slice(1);
                }
                
                this.invalidPacketsRejected++;
                return null;
            }

            // Extract packet data
            const packet = this.buffer.slice(0, totalSize);
            const avData = packet.slice(this.HEADER_SIZE);

            // Remove packet from buffer
            this.buffer = this.buffer.slice(totalSize);
            this.validPacketsExtracted++;

            // Log on first successful packet
            if (this.validPacketsExtracted === 1) {
                log(`✅ Stream ${this.streamId} extracted first valid packet: ID=${packetId}, size=${avData.byteLength}`);
            }

            return {
                packetId,
                timestamp,
                duration,
                segmentDuration,
                avData
            };
        } catch (e) {
            log(`❌ Stream ${this.streamId} error extracting packet: ${e.message}`);
            // Corrupted data - discard first byte and try again next time
            this.buffer = this.buffer.slice(1);
            this.invalidPacketsRejected++;
            return null;
        }
    }
    
    /**
     * Scan buffer for MPEG-TS sync pattern (0x47 followed by valid header structure)
     * @private
     * @returns {number} Offset to the sync pattern or 0 if not found
     */
    _scanForSyncPattern() {
        // Need at least header size + 1 for sync byte
        if (this.buffer.byteLength < this.HEADER_SIZE + 1) {
            return 0;
        }
        
        // Scan for 0x47 sync byte followed by reasonable header values
        for (let i = 1; i < this.buffer.byteLength - this.HEADER_SIZE; i++) {
            if (this.buffer[i] === 0x47) {
                // Check if we could have a valid header at this position
                // Look back to see if there's enough space for a header before this sync byte
                if (i >= this.HEADER_SIZE) {
                    try {
                        const tempView = new DataView(
                            this.buffer.buffer, 
                            this.buffer.byteOffset + (i - this.HEADER_SIZE), 
                            this.HEADER_SIZE
                        );
                        
                        // Do basic validation of header fields
                        const packetId = tempView.getUint32(0, false);
                        const segmentDuration = tempView.getFloat32(16, false);
                        const avDataLen = tempView.getUint32(20, false);
                        
                        // Check if these values look reasonable
                        if (packetId >= 0 && packetId < this.MAX_VALID_PACKET_ID &&
                            segmentDuration > 0 && segmentDuration <= 10 &&
                            avDataLen > 0 && avDataLen < this.MAX_PACKET_SIZE) {
                            
                            // This looks like a potential valid header position
                            log(`🔍 Potential valid header at offset ${i - this.HEADER_SIZE}: ID=${packetId}, segDuration=${segmentDuration}, avDataLen=${avDataLen}`);
                            return i - this.HEADER_SIZE;
                        }
                    } catch (e) {
                        // Skip errors in validation
                    }
                }
                
                // Alternative: just return position of the sync byte
                // Uncomment if we want to skip directly to sync bytes
                // return i;
            }
        }
        
        return 0; // No pattern found
    }
    
    /**
     * Count how many complete packets are in the buffer
     * @private
     */
    _countCompletePackets() {
        let count = 0;
        let pos = 0;
        
        while (pos + this.HEADER_SIZE <= this.buffer.byteLength) {
            try {
                const view = new DataView(this.buffer.buffer, this.buffer.byteOffset + pos, this.HEADER_SIZE);
                const packetId = view.getUint32(0, false);
                const avDataLen = view.getUint32(20, false);
                
                // Basic validation
                if (!Number.isFinite(packetId) || packetId < 0 || packetId > this.MAX_VALID_PACKET_ID ||
                    !Number.isFinite(avDataLen) || avDataLen <= 0 || avDataLen > this.MAX_PACKET_SIZE) {
                    // Invalid header, move to next byte
                    pos++;
                    continue;
                }
                
                const totalSize = this.HEADER_SIZE + avDataLen;
                
                // If we have a complete packet
                if (pos + totalSize <= this.buffer.byteLength) {
                    count++;
                    pos += totalSize;
                } else {
                    break; // Wait for more data
                }
            } catch (e) {
                // Error reading header, move to next byte
                pos++;
            }
        }
        
        return count;
    }
    
    /**
     * Concatenate two Uint8Arrays
     * @private
     */
    _concatArrays(a, b) {
        const result = new Uint8Array(a.byteLength + b.byteLength);
        result.set(a, 0);
        result.set(b, a.byteLength);
        return result;
    }
    
    /**
     * Reset the buffer state
     */
    reset() {
        this.buffer = new Uint8Array(0);
    }
    
    /**
     * Get current buffer statistics
     */
    getStats() {
        return {
            streamId: this.streamId,
            bufferSize: this.buffer.byteLength,
            totalBytesReceived: this.totalBytesReceived,
            validPacketsExtracted: this.validPacketsExtracted,
            invalidPacketsRejected: this.invalidPacketsRejected
        };
    }
}

/**
 * Handle a single incoming WebTransport stream with support for fragmented packets
 * This version processes each chunk directly without requiring complete packets
 */
 async function handleIncomingStream(stream, packetHandler) {
    // Generate a unique ID for this stream
    const streamId = window.streamCounter;
    
    // Create a dedicated reader for this stream
    const reader = stream.getReader();
    window.activeReaders.push(reader);
    
    // Stats tracking
    let totalBytesReceived = 0;
    let chunksReceived = 0;
    let lastLogTime = Date.now();
    
    try {
        log(`📥 Processing incoming stream #${streamId}`);
        
        while (!window.disconnectionRequested) {
            const { value, done } = await reader.read();
            
            if (done) {
                log(`📤 Stream #${streamId} ended after receiving ${totalBytesReceived} total bytes`);
                break;
            }
            
            if (!value || value.byteLength === 0) {
                continue;
            }
            
            // Update stats
            chunksReceived++;
            totalBytesReceived += value.byteLength;
            
            // Process chunk directly with packet handler
            if (typeof packetHandler.processStreamChunk === 'function') {
                // Direct chunk processing for fragmentation support
                packetHandler.processStreamChunk(streamId, value);
            } else {
                // Create a buffer if needed (fallback to original method)
                if (!streamBuffer) {
                    const streamBuffer = new WebTransportStreamBuffer(streamId);
                }
                
                // Add this chunk to the stream's buffer
                streamBuffer.addChunk(value);
                
                // Extract and process any complete packets
                let packet;
                while ((packet = streamBuffer.extractPacket()) !== null) {
                    // Process the packet with the handler
                    packetHandler.processValidatedPacket(packet);
                    
                    // Update UI counter
                    const packetCounter = document.getElementById('packetCounter');
                    if (packetCounter) {
                        packetCounter.textContent = packetHandler.packetsReceived.toString();
                    }
                }
            }
            
            // Log progress periodically
            const now = Date.now();
            if (now - lastLogTime > 5000) { // Every 5 seconds
                log(`📊 Stream #${streamId} progress: ${chunksReceived} chunks, ${totalBytesReceived} bytes total`);
                
                // For enhanced handler, also log partial packet stats
                if (typeof packetHandler.getPartialStats === 'function') {
                    const stats = packetHandler.getPartialStats();
                    log(`📊 Partial packets: ${stats.activePartials} active, ${stats.completedPartialPackets}/${stats.totalPartialPackets} completed`);
                }
                
                // Run maintenance on partial packets
                if (typeof packetHandler.checkPartialPackets === 'function') {
                    packetHandler.checkPartialPackets();
                }
                
                lastLogTime = now;
            }
            
            // Update UI
            const packetCounter = document.getElementById('packetCounter');
            if (packetCounter) {
                packetCounter.textContent = packetHandler.packetsReceived.toString();
            }
        }
    } catch (error) {
        log(`❌ Error in stream #${streamId}: ${error.message}`);
    } finally {
        try {
            reader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
        
        const index = window.activeReaders.indexOf(reader);
        if (index !== -1) {
            window.activeReaders.splice(index, 1);
        }
        
        log(`🛑 Stream #${streamId} processing completed: ${totalBytesReceived} bytes total`);
    }
}

/**
 * Analyzes raw stream data to detect format issues and potential packet boundaries
 * Can be called when troubleshooting stream parsing problems
 */
 function analyzeStreamData(buffer, options = {}) {
    // Default options
    const opts = {
        maxScanBytes: 2048,           // Max bytes to scan
        sampleSize: 64,               // Sample size for pattern detection
        patternThreshold: 3,          // Min occurrences to declare a pattern
        assumedHeaderSize: 24,        // Default header size to try
        detectHeaderSize: true,       // Try to detect header size
        searchSyncBytes: true,        // Search for MPEG-TS sync bytes (0x47)
        showHexDump: true,            // Show hex dump of samples
        ...options
    };
    
    // Validate input
    if (!buffer || buffer.byteLength === 0) {
        log(`⚠️ Stream analysis: Empty buffer`);
        return;
    }
    
    // Limit scan size
    const scanSize = Math.min(buffer.byteLength, opts.maxScanBytes);
    log(`🔍 Analyzing stream data (${buffer.byteLength} bytes, scanning first ${scanSize})`);
    
    // Get a view of the buffer to scan
    const scanBuffer = buffer.slice(0, scanSize);
    
    // Basic statistics
    const stats = {
        nullBytes: 0,
        textCharacters: 0,
        binaryData: 0,
        potentialSyncBytes: 0
    };
    
    // Simple byte frequency analysis
    const byteFrequency = new Array(256).fill(0);
    const patterns = {}; // Store recurring byte patterns
    
    // 1. Scan bytes and record statistics
    for (let i = 0; i < scanBuffer.byteLength; i++) {
        const byte = scanBuffer[i];
        byteFrequency[byte]++;
        
        // Count byte types
        if (byte === 0) stats.nullBytes++;
        else if (byte >= 32 && byte <= 126) stats.textCharacters++; // ASCII printable
        else stats.binaryData++;
        
        // Check for MPEG-TS sync byte (0x47)
        if (byte === 0x47) stats.potentialSyncBytes++;
        
        // Record byte patterns (for header detection)
        if (i >= opts.sampleSize && opts.detectHeaderSize) {
            const pattern = scanBuffer.slice(i - opts.sampleSize, i);
            const patternKey = Array.from(pattern).join(',');
            patterns[patternKey] = (patterns[patternKey] || 0) + 1;
        }
    }
    
    // 2. Output basic data type assessment
    const bytesAnalyzed = scanBuffer.byteLength;
    const nullPercent = (stats.nullBytes / bytesAnalyzed * 100).toFixed(1);
    const textPercent = (stats.textCharacters / bytesAnalyzed * 100).toFixed(1);
    const binaryPercent = (stats.binaryData / bytesAnalyzed * 100).toFixed(1);
    
    log(`🔢 Byte composition: ${nullPercent}% null, ${textPercent}% text, ${binaryPercent}% binary`);
    
    // 3. Data type classification
    let dataTypeGuess = 'Unknown';
    if (textPercent > 60) {
        dataTypeGuess = 'Text protocol (HTTP, WebSocket, etc)';
    } else if (binaryPercent > 70) {
        dataTypeGuess = 'Binary protocol';
        
        // Check for common binary format signatures
        if (scanBuffer[0] === 0x1F && scanBuffer[1] === 0x8B) {
            dataTypeGuess = 'GZIP compressed data';
        } else if (scanBuffer[0] === 0x50 && scanBuffer[1] === 0x4B) {
            dataTypeGuess = 'ZIP compressed data';
        } else if (stats.potentialSyncBytes > 5) {
            dataTypeGuess = 'Potential MPEG-TS data';
        }
    }
    
    log(`🔍 Data type guess: ${dataTypeGuess}`);
    
    // 4. Show a hex dump of the first part of the buffer
    if (opts.showHexDump) {
        const hexLimit = Math.min(128, scanBuffer.byteLength);
        let hexDump = '';
        let textDump = '';
        
        for (let i = 0; i < hexLimit; i++) {
            // Add line breaks every 16 bytes
            if (i > 0 && i % 16 === 0) {
                hexDump += '\n';
                log(`🔍 ${hexDump}  |  ${textDump}`);
                hexDump = '';
                textDump = '';
            }
            
            const byte = scanBuffer[i];
            hexDump += byte.toString(16).padStart(2, '0') + ' ';
            
            // For text representation, show printable chars or dots
            if (byte >= 32 && byte <= 126) {
                textDump += String.fromCharCode(byte);
            } else {
                textDump += '.';
            }
        }
        
        // Output the last line if there's anything left
        if (hexDump) {
            log(`🔍 ${hexDump.padEnd(48, ' ')}  |  ${textDump}`);
        }
    }
    
    // 5. Pattern detection for potential headers
    if (opts.detectHeaderSize) {
        let repeatingPatterns = [];
        
        // Find patterns with frequency above threshold
        for (const [pattern, count] of Object.entries(patterns)) {
            if (count >= opts.patternThreshold) {
                repeatingPatterns.push({ pattern, count });
            }
        }
        
        // Sort by frequency
        repeatingPatterns.sort((a, b) => b.count - a.count);
        
        if (repeatingPatterns.length > 0) {
            const topPatterns = repeatingPatterns.slice(0, 3);
            let patternMsg = '📋 Potential repeating patterns detected:\n';
            
            for (const {pattern, count} of topPatterns) {
                patternMsg += `   - Pattern occurs ${count} times (potential header structure)\n`;
            }
            
            log(patternMsg);
            
            // Use pattern to guess header size
            const patternDistance = detectPatternDistance(scanBuffer, 0x47); // Use 0x47 (sync byte) as marker
            if (patternDistance > 0) {
                log(`📏 Potential header size: ${patternDistance} bytes (based on 0x47 sync byte pattern)`);
                
                if (patternDistance !== opts.assumedHeaderSize) {
                    log(`⚠️ This differs from the current header size of ${opts.assumedHeaderSize} bytes!`);
                }
            }
        } else {
            log(`📋 No clear repeating patterns detected`);
        }
    }
    
    // 6. Search for MPEG-TS sync bytes and potential packet boundaries
    if (opts.searchSyncBytes) {
        const syncPositions = [];
        
        for (let i = 0; i < scanBuffer.byteLength; i++) {
            if (scanBuffer[i] === 0x47) {
                syncPositions.push(i);
            }
        }
        
        if (syncPositions.length > 1) {
            log(`🔍 Found ${syncPositions.length} potential sync bytes (0x47)`);
            
            // Calculate distances between sync bytes to detect patterns
            const distances = [];
            for (let i = 1; i < syncPositions.length; i++) {
                distances.push(syncPositions[i] - syncPositions[i-1]);
            }
            
            // Count frequency of each distance to detect packet size
            const distanceFreq = {};
            for (const dist of distances) {
                distanceFreq[dist] = (distanceFreq[dist] || 0) + 1;
            }
            
            // Find most common distance (potential packet size)
            let mostCommonDist = 0;
            let maxCount = 0;
            for (const [dist, count] of Object.entries(distanceFreq)) {
                if (count > maxCount) {
                    mostCommonDist = parseInt(dist);
                    maxCount = count;
                }
            }
            
            if (mostCommonDist > 0 && maxCount >= 3) {
                log(`📏 Most common distance between sync bytes: ${mostCommonDist} bytes (appeared ${maxCount} times)`);
                log(`🔍 This suggests a packet size pattern of approximately ${mostCommonDist} bytes`);
                
                // Check if this conflicts with our packet handler's expectations
                const expectedPacketSize = opts.assumedHeaderSize + 188; // Header + MPEG-TS packet
                if (Math.abs(mostCommonDist - expectedPacketSize) > 10) {
                    log(`⚠️ Warning: Detected packet size (${mostCommonDist}) differs significantly from expected size (${expectedPacketSize})`);
                }
            } else {
                log(`📏 No clear pattern in sync byte distances detected`);
            }
        } else if (syncPositions.length === 1) {
            log(`🔍 Only one sync byte (0x47) found at position ${syncPositions[0]}`);
        } else {
            log(`🔍 No MPEG-TS sync bytes (0x47) found in the scan range`);
        }
    }
    
    return {
        dataTypeGuess,
        syncByteCount: stats.potentialSyncBytes,
        nullPercent: parseFloat(nullPercent),
        textPercent: parseFloat(textPercent),
        binaryPercent: parseFloat(binaryPercent),
        bytesAnalyzed
    };
}

/**
 * Detect the distance between repeating patterns in a buffer
 * Useful for guessing header size or packet boundaries
 */
function detectPatternDistance(buffer, markerByte) {
    const positions = [];
    
    // Find all occurrences of the marker byte
    for (let i = 0; i < buffer.byteLength; i++) {
        if (buffer[i] === markerByte) {
            positions.push(i);
        }
    }
    
    if (positions.length < 2) {
        return 0; // Not enough occurrences to detect pattern
    }
    
    // Calculate distances between consecutive positions
    const distances = [];
    for (let i = 1; i < positions.length; i++) {
        distances.push(positions[i] - positions[i-1]);
    }
    
    // Find the most common distance
    const distanceFreq = {};
    for (const dist of distances) {
        distanceFreq[dist] = (distanceFreq[dist] || 0) + 1;
    }
    
    let mostCommonDist = 0;
    let maxCount = 0;
    for (const [dist, count] of Object.entries(distanceFreq)) {
        if (count > maxCount) {
            mostCommonDist = parseInt(dist);
            maxCount = count;
        }
    }
    
    // Only return if pattern appears multiple times
    return (maxCount >= 3) ? mostCommonDist : 0;
}

/**
 * Diagnostic function to analyze all active streams and report issues
 * Add this function to debug WebTransport streams in real-time
 */
 function diagnoseStreamIssues() {
    log(`🩺 Running stream diagnostics...`);
    
    // Check if we have an active transport
    if (!window.transport) {
        log(`❌ No active WebTransport connection`);
        return;
    }
    
    // Check active readers/streams
    const activeReaderCount = window.activeReaders?.length || 0;
    log(`📊 Active streams: ${activeReaderCount}`);
    
    // Check packet handler
    if (!window.packetHandler) {
        log(`❌ No packet handler initialized`);
        return;
    }
    
    // Check fragment counter
    log(`📊 Total fragments: ${window.fragmentCounter || 0}`);
    
    // Check if HLS.js is enabled
    const hlsSupported = !!window.Hls && Hls.isSupported();
    log(`📊 HLS support: ${hlsSupported ? 'Yes' : 'No'}`);
    
    // Check if we have registered any blob URLs
    const blobUrlCount = window.blobUrlMap?.size || 0;
    log(`📊 Registered blob URLs: ${blobUrlCount}`);
    
    // Check if XHR interception is enabled
    log(`📊 XHR interception: ${window.xhrInterceptionEnabled ? 'Enabled' : 'Disabled'}`);
    
    // Validate packet handler structure
    const isPacketHandlerValid = validatePacketHandler();
    if (!isPacketHandlerValid) {
        log(`❌ Packet handler validation failed`);
    }
    
    // Check for potential protocol mismatches
    if (activeReaderCount > 0 && window.fragmentCounter === 0) {
        log(`⚠️ Streams are active but no fragments have been processed`);
        log(`🔍 This could indicate a protocol mismatch or packet format issue`);
        
        // Suggest analyzing buffer contents
        log(`💡 Try examining raw buffer contents with analyzeStreamData()`);
    }
    
    log(`✅ Stream diagnostics completed`);
}

/**
 * Validates the packet handler structure and integrity
 * @returns {boolean} Whether the packet handler is valid
 */
function validatePacketHandler() {
    if (!window.packetHandler) return false;
    
    // Check required methods
    const requiredMethods = [
        'processValidatedPacket',
        '_generateHLSManifest',
        '_updateHLSManifest',
        '_generateVideoPlaylist'
    ];
    
    for (const method of requiredMethods) {
        if (typeof window.packetHandler[method] !== 'function') {
            log(`❌ Packet handler missing required method: ${method}`);
            return false;
        }
    }
    
    // Check required properties
    if (!window.packetHandler.segments || typeof window.packetHandler.segments !== 'object') {
        log(`❌ Packet handler missing segments map`);
        return false;
    }
    
    if (!Array.isArray(window.packetHandler.fragments)) {
        log(`❌ Packet handler missing fragments array`);
        return false;
    }
    
    return true;
}

/**
 * Get a single stream buffer for analysis
 * @param {number} streamId - The ID of the stream to analyze
 * @returns {Uint8Array|null} - The buffer from the stream or null if not found
 */
function getStreamBuffer(streamId) {
    // This is a best-effort function since we don't have direct access to stream buffers
    // Implement a stream buffer registry if this is useful
    
    log(`⚠️ getStreamBuffer() requires a stream buffer registry to be implemented`);
    return null;
}

/**
 * Applies emergency fixes to the packet handler to attempt recovery from stream issues
 */
function repairStreamIssues() {
    log(`🔧 Attempting to repair stream issues...`);
    
    // Check if we have a packet handler
    if (!window.packetHandler) {
        log(`❌ No packet handler to repair`);
        return;
    }
    
    // Check stream state
    let streamBufferWithData = null;
    let streamBufferSize = 0;
    
    // Try to find a stream buffer with data for analysis
    try {
        // This would require additional tracking of stream buffers
        streamBufferWithData = getStreamBuffer();
    } catch (e) {
        log(`⚠️ Could not access stream buffers: ${e.message}`);
    }
    
    // Reset the content type expectation
    log(`🔧 Try adjusting decoder settings...`);
    
    // Emergency generation of HLS manifest if needed
    if (window.fragmentCounter === 0 && !window.packetHandler.hlsData) {
        log(`🔧 Generating emergency HLS manifest...`);
        
        try {
            window.packetHandler._generateHLSManifest();
            log(`✅ Emergency HLS manifest generated`);
        } catch (e) {
            log(`❌ Failed to generate emergency manifest: ${e.message}`);
        }
    }
    
    // Repair packet handler state if needed
    if (!window.masterPlaylistUrl && !window.videoPlaylistUrl) {
        log(`🔧 Repairing playlist state...`);
        window.masterPlaylistUrl = null;
        window.videoPlaylistUrl = null;
        
        // Re-enable XHR interception
        if (!window.xhrInterceptionEnabled) {
            log(`🔧 Re-enabling XHR interception...`);
            setupXHRInterception();
        }
    }
    
    // Check HEADER_SIZE constant - maybe it's wrong
    log(`🔧 Current header size expectation: 24 bytes`);
    log(`💡 Consider trying different header sizes (20, 24, 28, 32) if video doesn't play`);
    
    // Recommendation
    log(`✅ Repair attempt completed`);
    log(`💡 If issues persist, try restarting the connection with a new URL`);
}

/**
 * Updates the header parsing mechanism in real-time to try different header sizes
 * @param {number} newHeaderSize - The new header size to try
 * @param {boolean} [resetBuffers=true] - Whether to reset all buffers
 */
function updateHeaderSize(newHeaderSize, resetBuffers = true) {
    if (!newHeaderSize || newHeaderSize < 12 || newHeaderSize > 48) {
        log(`❌ Invalid header size: ${newHeaderSize}`);
        return;
    }
    
    log(`🔧 Updating header size to ${newHeaderSize} bytes (was 24)`);
    
    // Update the HEADER_SIZE property in WebTransportStreamBuffer prototype
    if (WebTransportStreamBuffer) {
        WebTransportStreamBuffer.prototype.HEADER_SIZE = newHeaderSize;
        log(`✅ WebTransportStreamBuffer header size updated to ${newHeaderSize}`);
    } else {
        log(`❌ Could not find WebTransportStreamBuffer class`);
    }
    
    // Reset all buffers if requested
    if (resetBuffers) {
        log(`🔧 Resetting all stream buffers...`);
        
        // This would require tracking all stream buffers
        // Implement if needed based on your architecture
    }
    
    // Suggestion for testing
    log(`💡 Try connecting again with the new header size of ${newHeaderSize} bytes`);
}

/**
 * Helper function to dump the content of a stream buffer to debug format issues
 * @param {Uint8Array} buffer - The buffer to dump
 * @param {Object} options - Dump options
 */
function dumpBuffer(buffer, options = {}) {
    if (!buffer || buffer.byteLength === 0) {
        log(`⚠️ Empty buffer`);
        return;
    }
    
    const opts = {
        maxBytes: 256,
        bytesPerLine: 16,
        showText: true,
        showOffsets: true,
        ...options
    };
    
    const byteCount = Math.min(buffer.byteLength, opts.maxBytes);
    log(`📋 Buffer dump (${byteCount} of ${buffer.byteLength} bytes):`);
    
    let line = '';
    let text = '';
    let offset = '';
    
    for (let i = 0; i < byteCount; i++) {
        // Add line break and print previous line
        if (i > 0 && i % opts.bytesPerLine === 0) {
            const output = opts.showOffsets ? `${offset} | ${line}` : line;
            const fullOutput = opts.showText ? `${output}  |  ${text}` : output;
            log(fullOutput);
            line = '';
            text = '';
            offset = i.toString(16).padStart(8, '0');
        }
        
        // If this is the start of a line, prepare offset
        if (i % opts.bytesPerLine === 0) {
            offset = i.toString(16).padStart(8, '0');
        }
        
        // Format as hex
        const byte = buffer[i];
        line += byte.toString(16).padStart(2, '0') + ' ';
        
        // Format as text (printable ASCII or dot)
        if (byte >= 32 && byte <= 126) {
            text += String.fromCharCode(byte);
        } else {
            text += '.';
        }
    }
    
    // Print the last line if not complete
    if (line) {
        const paddedLine = line.padEnd(opts.bytesPerLine * 3, ' ');
        const output = opts.showOffsets ? `${offset} | ${paddedLine}` : paddedLine;
        const fullOutput = opts.showText ? `${output}  |  ${text}` : output;
        log(fullOutput);
    }
}

/**
 * Listen for incoming streams and process WebTransport data
 */
async function listenToIncomingStreams(transport, packetHandler) {
    // Reset stream counter
    window.streamCounter = 0;
    
    try {
        log("🎧 Listening for incoming streams...");
        
        // Handle readable streams from the server
        const reader = transport.incomingUnidirectionalStreams.getReader();
        
        // Track active readers for cleanup
        window.activeReaders = [];
        
        while (!window.disconnectionRequested) {
            const { value: stream, done } = await reader.read();
            
            if (done) {
                log("📢 Server finished sending streams");
                break;
            }
            
            // Increment stream counter
            window.streamCounter++;
            
            // Update UI
            const streamCounter = document.getElementById('streamCounter');
            if (streamCounter) {
                streamCounter.textContent = window.streamCounter.toString();
            }
            
            // Handle this specific stream with its own dedicated buffer
            handleIncomingStream(stream, packetHandler);
        }
    } catch (error) {
        log(`❌ Error in stream listener: ${error.message}`);
        if (!window.disconnectionRequested) {
            // Only show error message if not intentionally disconnected
            handleConnectionClosed();
        }
    }
}

function enhanceXHRDebugging() {
    // Only run this if XHR interception is already enabled
    if (!window.xhrInterceptionEnabled) return;
    
    log("🔍 Enhancing XMLHttpRequest debugging");
    
    // Store the original send method
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    // Override send method to add additional logging
    XMLHttpRequest.prototype.send = function(body) {
        // Log segment requests for debugging purposes
        log(`📦 START Checking blobUrlMap for segment: ${this._segmentName}`);
        if (this._isMediaSegment) {
            log(`🔍 XHR REQUEST: Segment=${this._segmentName || "unknown"}, URL=${this._url}`);
            
            // Check if we have this segment registered
            if (window.blobUrlMap && this._segmentName) {
                const hasSegment = window.blobUrlMap.has(this._segmentName);
                log(`🔍 Blob map has segment "${this._segmentName}": ${hasSegment}`);
                
                // If not found, log available segment names for debugging
                if (!hasSegment && window.blobUrlMap.size < 20) {
                    log(`🔍 Available segments: ${Array.from(window.blobUrlMap.keys()).filter(k => k.includes('.ts')).join(', ')}`);
                }
            }
        }
        
        if (this._isMediaSegment && this._segmentName) {
            log(`🔍 Segment requested: ${this._segmentName}`);
            
            if (window.blobUrlMap && window.blobUrlMap.has(this._segmentName)) {
                const segmentData = window.blobUrlMap.get(this._segmentName);
                log(`✅ Serving segment: ${this._segmentName} (size: ${segmentData.byteLength} bytes)`);
                // ...
            } else {
                log(`❌ Segment not found: ${this._segmentName}`);
                // Log available segments
                if (window.blobUrlMap) {
                    log(`🔍 Available segments: ${Array.from(window.blobUrlMap.keys()).filter(k => k.includes('.ts')).join(', ')}`);
                }
            }
        }

        // Call the original send method
        return originalXHRSend.call(this, body);
    };
    
    log(`✅ XHR debugging enhancement completed`);
    return true;
}

    /**
     * Set up XHR interception for HLS.js segment requests
     */
    function setupXHRInterception() {
        if (window.xhrInterceptionEnabled) return;
        
        log("🔄 Setting up XMLHttpRequest interception for HLS");
        window.xhrInterceptionEnabled = true;
        
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;
        
        // Create a map to store blob URLs and their corresponding data
        const blobUrlMap = new Map();
        
        // Add method to register manifest blob URLs
        window.registerManifestBlobUrl = (url, manifestData) => {
            blobUrlMap.set(url, manifestData);
            log(`📄 Registered manifest blob URL: ${url}`);
        };
        
        // Override open method to track request type
    // In setupXHRInterception(), update the XMLHttpRequest.prototype.open override:
    XMLHttpRequest.prototype.open = function(method, url, async) {
        this._url = url;
        this._method = method;
        
        if (method === 'GET' && typeof url === 'string') {
            log(`🔍 XHR Request: ${method} ${url}`);
        }
        
        // Track request type with improved patterns
        if (typeof url === 'string') {
            // Blob URLs for manifests we've registered
            if (url.startsWith('blob:') && window.blobUrlMap && window.blobUrlMap.has(url)) {
                this._isManifestBlobUrl = true;
                log(`📄 Recognized manifest blob URL: ${url}`);
            }
            // HLS manifest (.m3u8) requests
            else if (url.includes('.m3u8') || url === 'video.m3u8' || url === 'playlist.m3u8') {
                this._isManifestRequest = true;
                log(`📄 HLS manifest request detected: ${url}`);
            } 
            else if (url.includes('.ts') || url.match(/chunk-\d+\.ts/)) {
                this._isMediaSegment = true;
                
                // Extract the exact segment name from the URL
                const urlParts = url.split('/');
                const segmentName = urlParts[urlParts.length - 1];
                
                // Store the segment name for later use
                this._segmentName = segmentName;
                log(`🧲 Intercepted XHR open for: ${url} → segment name: ${segmentName}`);

                
                // Try to extract segment ID from pattern
                const matchSegment = segmentName.match(/chunk-(\d+)\.ts/);
                if (matchSegment) {
                    this._segmentId = parseInt(matchSegment[1]);
                    this._trackId = 0; // Default to video track for TS segments
                    log(`🎬 TS segment request: segment=${this._segmentId}, name=${segmentName}`);
                }
            }
        }
        
        originalXHROpen.call(this, method, url, async !== false);
    };
    
    // Override send method to serve content from our buffer
    XMLHttpRequest.prototype.send = function(body) {
        // External requests - always pass through
        if (this._isExternalRequest) {
            originalXHRSend.call(this, body);
            return;
        }
        
        // Manifest Blob URL Request - serve from our map
        if (this._isManifestBlobUrl && blobUrlMap.has(this._url)) {
            log(`📄 Serving registered manifest blob from map (${this._url})`);
            
            const manifestData = blobUrlMap.get(this._url);
            log(`📄 MANIFEST BLOB CONTENT:\n${manifestData}`);            
            
            setTimeout(() => {
                this.responseType = 'text';
                Object.defineProperty(this, 'response', { get: () => manifestData });
                Object.defineProperty(this, 'responseText', { get: () => manifestData });
                Object.defineProperty(this, 'status', { get: () => 200 });
                Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                Object.defineProperty(this, 'readyState', { get: () => 4 });
                
                this.dispatchEvent(new Event('readystatechange'));
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('loadend'));
                
                log(`✅ Blob manifest served successfully`);
            }, 10);
            
            return;
        }
        
        // HLS Manifest Request
        if (this._isManifestRequest && window.packetHandler?.hlsData) {
            log(`📄 Serving HLS manifest from WebTransport packet (${window.packetHandler.hlsData.length} bytes)`);
            log(`📄 M3U8 CONTENT:\n${window.packetHandler.hlsData}`);
            
            setTimeout(() => {
                this.responseType = 'text';
                Object.defineProperty(this, 'response', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'responseText', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'status', { get: () => 200 });
                Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                Object.defineProperty(this, 'readyState', { get: () => 4 });
                
                this.dispatchEvent(new Event('readystatechange'));
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('loadend'));
                
                log(`✅ HLS manifest served successfully`);
            }, 10);
            
            return;
        }
        
        // Init Segment Request
        if (this._isInitSegment && typeof this._trackId !== 'undefined') {
            const trackId = this._trackId;
            const trackType = trackId === 0 ? "video" : "audio";
            
            // Check if we have an init segment for this track
            if (window.packetHandler?.init[trackType]) {
                const initData = window.packetHandler.init[trackType];
                log(`🔑 Serving ${trackType} init segment (${initData.byteLength} bytes)`);
                
                setTimeout(() => {
                    // Make sure we're using the correct responseType
                    this.responseType = 'arraybuffer';
                    
                    // Make sure we're serving an ArrayBuffer, not a TypedArray
                    let buffer;
                    if (initData instanceof Uint8Array) {
                        buffer = initData.buffer.slice(
                            initData.byteOffset, 
                            initData.byteOffset + initData.byteLength
                        );
                    } else {
                        buffer = initData;
                    }
                    
                    // Set the correct response properties
                    Object.defineProperty(this, 'response', { get: () => buffer });
                    Object.defineProperty(this, 'status', { get: () => 200 });
                    Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                    Object.defineProperty(this, 'readyState', { get: () => 4 });
                    
                    // Dispatch events to signal completion
                    this.dispatchEvent(new Event('readystatechange'));
                    this.dispatchEvent(new Event('load'));
                    this.dispatchEvent(new Event('loadend'));
                    
                    log(`✅ Init segment served: track=${trackId}`);
                }, 10);
                
                return;
            } else {
                log(`⚠️ No init segment available for track ${trackId}`);
            }
        }
        
        if (this._isMediaSegment) {
            // First look for segments by name if available
            log(`📦 Checking for segment: ${this._segmentName}`);
            log(`📦 isMediaSegment=${this._isMediaSegment}`);

            if (this._segmentName && window.blobUrlMap && window.blobUrlMap.has(this._segmentName)) {
                const segmentData = window.blobUrlMap.get(this._segmentName);
                serveSegmentData(this, segmentData, this._segmentName);
                return;
            }
            
            // Then try by ID if we have that
            if (this._trackId !== undefined && this._segmentId !== undefined && window.packetHandler) {
                const trackType = this._trackId === 0 ? "video" : "audio";
                if (window.packetHandler.buffer[trackType][this._segmentId]) {
                    const segmentData = window.packetHandler.buffer[trackType][this._segmentId];
                    serveSegmentData(this, segmentData, `segment-${this._trackId}-${this._segmentId}`);
                    log(`📦 Segment "${this._segmentName}" found in blob map, serving now`);

                    return;
                }
            }
            
            // No segment found, respond with 404
            log(`⚠️ No media segment found for: ${this._segmentName || this._url}`);
            respondWith404(this);
            return;
        }
        
        // Fall back to original XHR behavior for any unhandled requests
        originalXHRSend.call(this, body);
    };
    
    log(`✅ XHR interception setup completed for HLS.js`);
    return true;
}

// Helper function to serve segment data
function serveSegmentData(xhr, data, segmentName) {
    log(`🎬 Serving segment: ${segmentName} (${data.byteLength} bytes)`);
    
    setTimeout(() => {
        xhr.responseType = 'arraybuffer';
        let buffer;
        if (data instanceof Uint8Array) {
            buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
        } else {
            buffer = data;
        }
        
        Object.defineProperty(xhr, 'response', { get: () => buffer });
        Object.defineProperty(xhr, 'status', { get: () => 200 });
        Object.defineProperty(xhr, 'statusText', { get: () => 'OK' });
        Object.defineProperty(xhr, 'readyState', { get: () => 4 });
        
        xhr.dispatchEvent(new Event('readystatechange'));
        xhr.dispatchEvent(new Event('load'));
        xhr.dispatchEvent(new Event('loadend'));
        
        log(`✅ Media segment served: ${segmentName}`);
    }, 10);
}

// Helper function to respond with 404
function respondWith404(xhr) {
    setTimeout(() => {
        Object.defineProperty(xhr, 'status', { get: () => 404 });
        Object.defineProperty(xhr, 'statusText', { get: () => 'Not Found' });
        Object.defineProperty(xhr, 'readyState', { get: () => 4 });
        
        xhr.dispatchEvent(new Event('readystatechange'));
        xhr.dispatchEvent(new Event('load'));
        xhr.dispatchEvent(new Event('loadend'));
    }, 10);
}

/**
 * Enhanced generateVideoPlaylist function that filters out invalid segments
 */
 function generateVideoPlaylist(packetHandler) {
    // Constants for validation
    const MIN_SEGMENT_SIZE = 50 * 1024; // 50 KB minimum size
    const MAX_SEGMENT_ID = 100000;      // Maximum reasonable segment ID
    const MAX_ALLOWED_GAP = 5;          // Maximum allowed gap in sequence

    // Create the basic playlist structure
    let videoPlaylist = '#EXTM3U\n';
    videoPlaylist += '#EXT-X-VERSION:3\n';
    videoPlaylist += '#EXT-X-TARGETDURATION:4\n';
    videoPlaylist += '#EXT-X-MEDIA-SEQUENCE:0\n';

    // Get all video segments, filter and sort them
    const videoSegments = Object.keys(packetHandler.buffer.video)
        .map(Number)
        .filter(id => {
            // Basic validation
            if (!Number.isFinite(id) || id < 0 || id > MAX_SEGMENT_ID) {
                log(`⚠️ Filtering out invalid segment ID: ${id}`);
                return false;
            }
            
            // Size validation
            const segment = packetHandler.buffer.video[id];
            if (!segment || !segment.byteLength || segment.byteLength < MIN_SEGMENT_SIZE) {
                log(`⚠️ Filtering out small segment #${id} (size=${segment?.byteLength || 0})`);
                return false;
            }
            
            return true;
        })
        .sort((a, b) => a - b);

    // Handle empty case
    if (videoSegments.length === 0) {
        videoPlaylist += '#EXTINF:4.0,\n';
        videoPlaylist += 'chunk-00000.ts\n';
        
        // Register with our manifest blob map
        if (typeof window.registerManifestBlobUrl === 'function') {
            window.registerManifestBlobUrl('video.m3u8', videoPlaylist);
        }
        
        return videoPlaylist;
    }

    // Process segments with sequence validation
    let includedCount = 0;
    let lastIncludedId = null;

    for (let i = 0; i < videoSegments.length; i++) {
        const segId = videoSegments[i];
        const segment = packetHandler.buffer.video[segId];
        
        // Skip non-sequential segments (prevent large gaps)
        if (lastIncludedId !== null && (segId - lastIncludedId) > MAX_ALLOWED_GAP) {
            log(`⚠️ Skipping out-of-sequence segment #${segId} (last was #${lastIncludedId})`);
            continue;
        }
        
        // Find segment duration from track buffers if available
        let segmentDuration = 4.0; // Default
        const segmentInfo = packetHandler.trackBuffers[0]?.fragments.find(f => f.sequence === segId);
        
        if (segmentInfo && Number.isFinite(segmentInfo.segmentDuration) && 
            segmentInfo.segmentDuration > 0 && segmentInfo.segmentDuration <= 10) {
            segmentDuration = segmentInfo.segmentDuration;
        }

        // Add segment to playlist with proper formatting
        videoPlaylist += `#EXTINF:${segmentDuration.toFixed(3)},\n`;
        const segmentName = `chunk-${segId.toString().padStart(5, '0')}.ts`;
        videoPlaylist += `${segmentName}\n`;

        lastIncludedId = segId;
        includedCount++;
    }

    // Add end list marker if disconnected
    if (packetHandler.isDisconnected) {
        videoPlaylist += '#EXT-X-ENDLIST\n';
    }

    // Register with our manifest blob map
    if (typeof window.registerManifestBlobUrl === 'function') {
        window.registerManifestBlobUrl('video.m3u8', videoPlaylist);
    }
    
    log(`📄 Generated video playlist with ${includedCount} valid segments`);
    return videoPlaylist;
}

/**
 * Initialize an enhanced HLS.js player with comprehensive event monitoring
 * Combines functionality from both initializeHLSPlayer and enhanceHLSEventMonitoring
 * 
 * @param {string} hlsUrl - URL to the HLS manifest
 * @returns {Hls|null} - The initialized HLS.js player instance or null if initialization failed
 */
 function initializeHLSPlayer(hlsUrl = '/vivoh.m3u8') {
    try {
        // Check for HLS.js library
        if (!window.Hls) {
            log("❌ HLS.js library not found!");
            return null;
        }
        
        // Check browser compatibility
        if (!Hls.isSupported()) {
            log("❌ HLS.js is not supported in this browser");
            return null;
        }
        
        // Find video element
        const videoElement = document.getElementById('videoElement');
        if (!videoElement) {
            log("❌ Video element not found");
            return null;
        }
        
        // Clean up any existing player instance
        if (window.player) {
            try {
                // Clear any existing event listeners
                if (window.hlsListeners && window.hlsListeners.length > 0) {
                    window.hlsListeners.forEach(([event, callback]) => {
                        window.player.off(event, callback);
                    });
                    window.hlsListeners = [];
                }
                
                // Destroy the player
                window.player.destroy();
                log("🧹 Destroyed previous HLS.js instance");
            } catch (e) {
                log(`⚠️ Error destroying previous player: ${e.message}`);
            }
            window.player = null;
        }
        
        // Clear interval timers
        if (window.bufferStateInterval) {
            clearInterval(window.bufferStateInterval);
            window.bufferStateInterval = null;
        }
        
        log(`🔧 Creating new HLS.js player with URL: ${hlsUrl}`);
        
        // Create HLS.js player with optimized configuration
        const hls = new Hls({
            debug: false, // Set to true for even more verbose HLS.js logging
            enableWorker: true,
            lowLatencyMode: true,
            startLevel: 0,
            defaultAudioCodec: 'mp4a.40.2',
            
            // Live stream settings
            liveSyncDurationCount: 3,
            liveMaxLatencyDurationCount: 10,
            
            // Buffer settings
            maxBufferLength: 30,
            maxBufferSize: 60 * 1000 * 1000, // 60MB
            
            // Fragment loading settings
            fragLoadingMaxRetry: 8,
            manifestLoadingMaxRetry: 8,
            levelLoadingMaxRetry: 8,
            fragLoadingRetryDelay: 1000,
            
            // Error handling
            appendErrorMaxRetry: 3,
            recoverMediaError: true,
            recoverNetworkError: true,
            
            // Performance and stall prevention
            maxBufferHole: 0.5,
            maxStarvationDelay: 4000,
            maxLoadingDelay: 4,
            
            // Seeking
            exactManifestTolerance: 0.5
        });
        
        // Initialize buffer state tracking
        window.hlsBufferState = {
            audio: { buffered: [], appended: 0 },
            video: { buffered: [], appended: 0 },
            lastUpdate: Date.now()
        };

        // Clear any existing video element event listeners
        const eventHandlers = {
            error: videoErrorHandler,
            canplay: videoCanPlayHandler,
            playing: videoPlayingHandler,
            stalled: videoStalledHandler,
            waiting: videoWaitingHandler,
            loadstart: videoLoadStartHandler,
            progress: videoProgressHandler,
            timeupdate: videoTimeUpdateHandler,
            pause: videoPauseHandler,
            seeking: videoSeekingHandler,
            seeked: videoSeekedHandler,
            ended: videoEndedHandler
        };
        
        Object.entries(eventHandlers).forEach(([event, handler]) => {
            videoElement.removeEventListener(event, handler);
            videoElement.addEventListener(event, handler);
        });
        
        // Initialize array to track HLS.js event listeners for cleanup
        window.hlsListeners = [];
        
        // Helper function to add HLS event listeners and track them
        function addHlsListener(event, callback) {
            hls.on(event, callback);
            window.hlsListeners.push([event, callback]);
        }
        
        // Set up comprehensive HLS.js event monitoring
        
        // Media Attachment Events
        addHlsListener(Hls.Events.MEDIA_ATTACHING, () => {
            log("🎬 Attempting to attach HLS.js to media element");
        });
        
        addHlsListener(Hls.Events.MEDIA_ATTACHED, () => {
            log("🎬 HLS.js attached to media element");
            
            // Update player state
            window.playerState = 'attached';
            updateUI();
            
            // Load source after attaching
            log(`🔗 Loading source: ${hlsUrl}`);
            hls.loadSource(hlsUrl);
        });
        
        addHlsListener(Hls.Events.MEDIA_DETACHING, () => {
            log("🎬 Detaching HLS.js from media element");
        });
        
        addHlsListener(Hls.Events.MEDIA_DETACHED, () => {
            log("🎬 HLS.js detached from media element");
            window.playerState = 'detached';
            updateUI();
        });
        
        // Manifest Events
        addHlsListener(Hls.Events.MANIFEST_LOADING, (event, data) => {
            log(`📄 Loading HLS manifest: ${data.url}`);
            window.playerState = 'loading';
            updateUI();
        });
        
        addHlsListener(Hls.Events.MANIFEST_LOADED, (event, data) => {
            log(`📄 HLS manifest loaded: ${data.url}`);
            
            if (data.levels && data.levels.length > 0) {
                log(`📄 HLS manifest contains ${data.levels.length} levels`);
                data.levels.forEach((level, index) => {
                    log(`📄 Level ${index}: ${level.url}`);
                });
            }
        });
        
        addHlsListener(Hls.Events.MANIFEST_PARSED, (event, data) => {
            log(`📄 HLS manifest parsed: ${data.levels.length} quality levels`);
            
            // Update player state
            window.playerState = 'ready';
            updateUI();
            
            // Enable play button
            const playButton = document.getElementById('playButton');
            if (playButton) {
                playButton.disabled = false;
                log(`✅ Play button enabled`);
            }
            videoElement.play().then(() => {
                log(`▶️ Autoplay success after manifest parsed`);
            }).catch(err => {
                log(`⚠️ Autoplay failed after manifest parsed: ${err.message}`);
            });

        });
        
        // Level Events
        addHlsListener(Hls.Events.LEVEL_SWITCHING, (event, data) => {
            log(`📊 Switching to level ${data.level}`);
        });
        
        addHlsListener(Hls.Events.LEVEL_SWITCHED, (event, data) => {
            log(`📊 Switched to level ${data.level}`);
        });
        
        addHlsListener(Hls.Events.LEVEL_LOADING, (event, data) => {
            log(`📊 Loading level ${data.level}`);
        });
        
        addHlsListener(Hls.Events.LEVEL_LOADED, (event, data) => {
            log(`📊 Level ${data.level} loaded with ${data.details.fragments.length} fragments, duration=${data.details.totalduration.toFixed(2)}s`);
            
            // Update fragment count in UI from HLS.js data
            const bufferStatus = document.getElementById('bufferStatus');
            if (bufferStatus && data.details.fragments) {
                bufferStatus.textContent = `${data.details.fragments.length} fragments`;
                
                // Also update our counter to match
                fragmentCounter = data.details.fragments.length;
            }
        });
        
        // Fragment Events
        addHlsListener(Hls.Events.FRAG_LOADING, (event, data) => {
            log(`📦 Loading fragment: ${data.frag.relurl || data.frag.url}, sn=${data.frag.sn}, level=${data.frag.level}`);
        });
        
        addHlsListener(Hls.Events.FRAG_LOADED, (event, data) => {
            log(`✅ Fragment loaded: ${data.frag.relurl || data.frag.url}, size=${data.frag.loaded} bytes, duration=${data.frag.duration.toFixed(2)}s`);
        });
        
        addHlsListener(Hls.Events.FRAG_PARSING_INIT_SEGMENT, (event, data) => {
            log(`🔑 Parsing init segment for ${data.id}`);
        });
        
        addHlsListener(Hls.Events.FRAG_PARSING_DATA, (event, data) => {
            const type = data.type;
            window.hlsBufferState[type].appended++;
            
            // Only log this occasionally to reduce noise
            if (window.hlsBufferState[type].appended % 5 === 0) {
                log(`⚙️ Parsed fragment data: type=${type}, pts=${data.startPTS.toFixed(2)}-${data.endPTS.toFixed(2)}, duration=${(data.endPTS - data.startPTS).toFixed(2)}s`);
            }
            
            // Update UI to show fragments being processed
            const bufferStatus = document.getElementById('bufferStatus');
            if (bufferStatus) {
                const videoCount = window.hlsBufferState.video.appended;
                const audioCount = window.hlsBufferState.audio.appended;
                bufferStatus.textContent = `${videoCount + audioCount} fragments`;
            }
        });
        
        addHlsListener(Hls.Events.FRAG_PARSED, (event, data) => {
            log(`🧩 Fragment fully parsed: level=${data.frag.level}, sn=${data.frag.sn}`);
        });
        
        // Buffer Events
        addHlsListener(Hls.Events.BUFFER_CREATED, (event, data) => {
            log(`📋 Media buffer created`);
        });
        
        addHlsListener(Hls.Events.BUFFER_APPENDING, (event, data) => {
            log(`📋 Appending to ${data.type} buffer: ${data.data.byteLength} bytes`);
        });
        
        addHlsListener(Hls.Events.BUFFER_APPENDED, (event, data) => {
            log(`📋 Appended to ${data.type} buffer`);
        });
        
        addHlsListener(Hls.Events.BUFFER_FLUSHED, (event, data) => {
            log(`📋 Buffer flushed: ${data.type}`);
        });
        
        addHlsListener(Hls.Events.BUFFER_EOS, (event, data) => {
            log(`📋 Buffer EOS (End of Stream) reached`);
        });
        
        // Error Handling
        addHlsListener(Hls.Events.ERROR, (event, data) => {
            // Map error types to readable names
            const errorTypes = {
                [Hls.ErrorTypes.NETWORK_ERROR]: 'Network',
                [Hls.ErrorTypes.MEDIA_ERROR]: 'Media',
                [Hls.ErrorTypes.MUX_ERROR]: 'Multiplexing',
                [Hls.ErrorTypes.OTHER_ERROR]: 'Other'
            };
            
            const errorType = errorTypes[data.type] || data.type;
            const errorDetails = data.details || 'unknown';
            const isFatal = !!data.fatal;
            
            log(`❌ ${isFatal ? 'FATAL ' : ''}${errorType} ERROR: ${errorDetails}`);
            console.error("Error data:", data);
            
            if (data.response) {
                log(`❌ Response error: Status=${data.response.code}, URL=${data.response.url}`);
            }
            
            // Add more details based on error type
            if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                log(`❌ Network error context: ${JSON.stringify({
                    url: data.context?.url,
                    status: data.context?.status,
                    networkDetails: data.networkDetails?.status
                })}`);
            } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                log(`❌ Media error context: ${data.context || 'No context'}`);
            }
            
            // Handle fatal errors with recovery attempts
            if (data.fatal) {
                log(`⚠️ Fatal error: ${data.details}`);
                
                // Update player state
                window.playerState = 'error';
                updateUI();
                
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        log("🔄 Attempting to recover from network error");
                        hls.startLoad();
                        break;
                    case Hls.ErrorTypes.MEDIA_ERROR:
                        log("🔄 Attempting to recover from media error");
                        hls.recoverMediaError();
                        break;
                    default:
                        log("❌ Cannot recover from error");
                        break;
                }
            }
            log(`⚠️ HLS.js error: ${data.type}, ${data.details}, fatal: ${data.fatal}`);
            console.error("Error details:", data);
        });
        
        // Set up periodic buffer state monitoring
        window.bufferStateInterval = setInterval(() => {
            if (!hls || !hls.media) return;
            
            const video = hls.media;
            const buffered = [];
            
            for (let i = 0; i < video.buffered.length; i++) {
                buffered.push({
                    start: video.buffered.start(i),
                    end: video.buffered.end(i)
                });
            }
            
            const currentTime = video.currentTime;
            const bufferedAhead = getBufferedAheadOf(video.buffered, currentTime);
            
            // Only log this every 5 seconds to reduce noise
            if (Date.now() - window.hlsBufferState.lastUpdate > 5000) {
                log(`📊 Buffer state: currentTime=${currentTime.toFixed(2)}s, bufferedAhead=${bufferedAhead.toFixed(2)}s, ranges=${buffered.length}`);
                window.hlsBufferState.lastUpdate = Date.now();
            }
            
            // Update fragments count in UI
            const bufferStatus = document.getElementById('bufferStatus');
            if (bufferStatus) {
                const fragmentCount = window.hlsBufferState.video.appended + window.hlsBufferState.audio.appended;
                if (fragmentCount > 0) {
                    bufferStatus.textContent = `${fragmentCount} fragments`;
                }
            }
        }, 2000);
        
        // Attach to video element
        hls.attachMedia(videoElement);
        
        // Store the player globally
        window.player = hls;
        log(`✅ HLS.js player initialized with URL: ${hlsUrl}`);
        
        return hls;
    } catch (error) {
        log(`❌ Error initializing HLS player: ${error.message}`);
        return null;
    }
}

// Video element event handlers (named functions to allow removal)
function videoErrorHandler(e) {
    const videoElement = document.getElementById('videoElement');
    log(`❌ Video element error: ${videoElement.error?.code}, ${videoElement.error?.message}`);
    
    window.playerState = 'error';
    updateUI();
}

function videoCanPlayHandler() {
    log(`✅ Video can play`);
    
    // Don't change player state, let 'playing' do that
}

function videoPlayingHandler() {
    log(`▶️ Video started playing`);
    
    window.playerState = 'playing';
    updateUI();
}

function videoStalledHandler() {
    log(`⏸️ Video playback stalled`);
    
    window.playerState = 'buffering';
    updateUI();
}

function videoWaitingHandler() {
    log(`⏸️ Video waiting for data`);
    
    window.playerState = 'buffering';
    updateUI();
}

function videoLoadStartHandler() {
    log(`🔄 Video load starting`);
}

function videoProgressHandler() {
    // This fires frequently, so we don't log it
}

function videoTimeUpdateHandler() {
    // This fires frequently, so we don't log it
}

function videoPauseHandler() {
    log(`⏸️ Video paused`);
    
    window.playerState = 'paused';
    updateUI();
}

function videoSeekingHandler() {
    log(`⏭️ Video seeking`);
}

function videoSeekedHandler() {
    log(`⏭️ Video seeked`);
}

function videoEndedHandler() {
    log(`⏹️ Video playback ended`);
    
    window.playerState = 'ended';
    updateUI();
}

// Helper function to get amount of media buffered ahead of current position
function getBufferedAheadOf(buffered, position) {
    for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        
        if (position >= start && position < end) {
            return end - position;
        }
    }
    return 0;
}

function updatePlayButton() {
    const playButton = document.getElementById('playButton');
    if (!playButton) return;
    
    // Remove any existing click handlers
    const newPlayButton = playButton.cloneNode(true);
    playButton.parentNode.replaceChild(newPlayButton, playButton);
    
    // Add a new click handler
    newPlayButton.addEventListener('click', function() {
        log(`🎮 Play button clicked`);
        
        try {
            if (window.player && window.player.media) {
                log(`▶️ Player exists, attempting to play media...`);
                
                const videoPromise = window.player.media.play();
                
                if (videoPromise !== undefined) {
                    videoPromise.then(() => {
                        log(`✅ Playback started successfully`);
                        window.playerState = 'playing';
                        updateUI();
                    }).catch(err => {
                        log(`❌ Playback failed: ${err.message}`);
                        
                        // Try to recover from autoplay restrictions
                        if (err.name === 'NotAllowedError') {
                            log(`⚠️ Autoplay blocked by browser, need user gesture`);
                            alert('Please click play again - browser requires user interaction');
                        }
                    });
                }
            } else if (window.packetHandler && window.packetHandler.hlsUrl) {
                log(`🔄 No player or media, initializing with URL: ${window.packetHandler.hlsUrl}`);
                
                // Initialize the player
                const player = initializeHLSPlayer(window.packetHandler.hlsUrl);
                
                // Wait a moment for initialization then try playing
                setTimeout(() => {
                    if (window.player && window.player.media) {
                        log(`⏱️ Delayed play attempt...`);
                        
                        window.player.media.play().catch(err => {
                            log(`❌ Delayed play failed: ${err.message}`);
                        });
                    }
                }, 1000);
            } else {
                log(`❌ No player or HLS URL available for playback`);
                alert('No media available for playback');
            }
        } catch (e) {
            log(`❌ Error during play attempt: ${e.message}`);
            console.error(e);
        }
    });
    
    log(`✅ Play button handler updated`);
}

function validateAndDebugManifest(manifestContent) {
    if (!manifestContent) {
        log(`❌ Empty manifest content!`);
        return false;
    }
    
    try {
        // Basic validation
        if (!manifestContent.includes('#EXTM3U')) {
            log(`❌ Invalid manifest - missing #EXTM3U header`);
            return false;
        }
        
        // Count segments
        const segmentCount = (manifestContent.match(/#EXTINF/g) || []).length;
        log(`📋 Manifest contains ${segmentCount} segments`);
        
        // Check for EXT-X-VERSION
        if (!manifestContent.includes('#EXT-X-VERSION')) {
            log(`⚠️ Manifest missing EXT-X-VERSION tag`);
        }
        
        // Check for media sequence
        if (!manifestContent.includes('#EXT-X-MEDIA-SEQUENCE')) {
            log(`⚠️ Manifest missing EXT-X-MEDIA-SEQUENCE tag`);
        }
        
        // Check if master playlist
        const isMasterPlaylist = manifestContent.includes('#EXT-X-STREAM-INF');
        
        if (isMasterPlaylist) {
            log(`📋 Manifest is a master playlist`);
            
            // Extract variant URLs
            const streamInfoPattern = /#EXT-X-STREAM-INF:([^\n]+)\n([^\n]+)/g;
            let match;
            let variantCount = 0;
            
            while ((match = streamInfoPattern.exec(manifestContent)) !== null) {
                variantCount++;
                const attributes = match[1];
                const variantUrl = match[2].trim();
                
                log(`📋 Found variant #${variantCount}: ${variantUrl}`);
                
                // For blob URLs, see if they're in the blobUrlMap
                if (variantUrl.startsWith('blob:') && window.blobUrlMap) {
                    if (window.blobUrlMap.has(variantUrl)) {
                        log(`✅ Variant URL exists in blob map`);
                    } else {
                        log(`❌ Variant URL not found in blob map: ${variantUrl}`);
                    }
                }
            }
        } else {
            // Media playlist
            log(`📋 Manifest is a media playlist with ${segmentCount} segments`);
            
            // Extract segment URLs and durations
            const segmentPattern = /#EXTINF:([^,]+)(?:,([^\n]+))?\n([^\n]+)/g;
            let match;
            let totalDuration = 0;
            
            while ((match = segmentPattern.exec(manifestContent)) !== null) {
                const duration = parseFloat(match[1]);
                const title = match[2] || '';
                const segmentUrl = match[3].trim();
                
                totalDuration += duration;
                
                if (segmentUrl.includes('.ts')) {
                    log(`📋 Segment: ${segmentUrl}, duration=${duration.toFixed(3)}s${title ? `, title=${title}` : ''}`);
                    
                    // Check if this segment is already registered
                    if (window.blobUrlMap && !window.blobUrlMap.has(segmentUrl)) {
                        log(`⚠️ Segment not registered in blob map: ${segmentUrl}`);
                    }
                }
            }
            
            log(`📋 Total playlist duration: ${totalDuration.toFixed(3)}s`);
        }
        
        return true;
    } catch (error) {
        log(`❌ Error validating manifest: ${error.message}`);
        return false;
    }
}

function setupPacketHandlerCallbacks() {
    if (!window.packetHandler) return;
    
    window.packetHandler.onHLSReady = (hlsUrl) => {
        log(`📄 HLS ready for playback: ${hlsUrl}`);
        
        if (!window.player) {
            initializeHLSPlayer(hlsUrl);
            
            // Update UI to reflect fragment count
            const bufferStatus = document.getElementById('bufferStatus');
            if (bufferStatus) {
                bufferStatus.textContent = `${fragmentCounter} fragments`;
            }
            
            // Update play button
            updatePlayButton();
        } else {
            log(`📄 Player already exists, loading source: ${hlsUrl}`);
            window.player.loadSource(hlsUrl);
        }
    };
    
    log("✅ Packet handler callbacks configured");
}

/**
 * Set up WebTransport with enhanced fragmentation support
 * This version uses the enhanced packet handler and stream processor
 */
 function setupWebTransport(url) {
    try {
        window.disconnectionRequested = false;
        
        log(`🔍 Setting up WebTransport with URL: ${url}`);
        
        // Reset fragment counter
        window.fragmentCounter = 0;
        
        // Clear any existing resources
        if (window.transport) {
            try { 
                window.transport.close(); 
            } catch (e) {
                log(`🔍 Error closing existing transport: ${e.message}`);
            }
            window.transport = null;
        }
        
        // Initialize packet handler for HLS
        window.packetHandler = new WebTransportHLSPacketHandler();
        
        // Set up improved callbacks
        setupPacketHandlerCallbacks();
        
        // Set up XHR interception before connecting
        setupXHRInterception();
        
        // Connect to WebTransport 
        log(`🔗 Connecting to WebTransport server: ${url}`);
        
        const createStartTime = Date.now();
        window.transport = new WebTransport(url);
        const createEndTime = Date.now();
        
        log(`📡 WebTransport object created in ${createEndTime - createStartTime}ms`);
        
        // Set up connection closed handler
        window.transport.closed.then(() => {
            log(`ℹ️ Connection closed normally`);
            if (!window.disconnectionRequested) {
                handleConnectionClosed();
            }
        }).catch((error) => {
            log(`❌ Connection closed with error: ${error.message}`);
            if (!window.disconnectionRequested) {
                handleConnectionClosed();
            }
        });
        
        // Listen for incoming streams
        listenToIncomingStreams(window.transport, window.packetHandler).catch(err => {
            log(`❌ Error in stream listener: ${err.message}`);
        });
        
        // Start status updates
        startStatusUpdates();
        
        // Update UI
        updateUI();
        
        // Update play button handler
        updatePlayButton();
        
        // Start periodic maintenance for partial packets
        window.partialPacketInterval = setInterval(() => {
            if (typeof window.packetHandler.checkPartialPackets === 'function') {
                window.packetHandler.checkPartialPackets();
            }
        }, 10000); // Every 10 seconds
        
        log(`✅ WebTransport setup completed successfully`);
        
        return window.packetHandler;
    } catch (error) {
        log(`❌ WebTransport error: ${error.message}`);
        updateUI();
        throw error;
    }
}

function enhanceXHRDebugging() {
    // Only run this if XHR interception is already enabled
    if (!window.xhrInterceptionEnabled) return;
    
    log("🔍 Enhancing XMLHttpRequest debugging for HLS.js");
    
    // Store the original open and send methods
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    // Add request/response timing tracking
    window.requestTimings = {};
    
    // Override open method with improved URL pattern detection
    XMLHttpRequest.prototype.open = function(method, url, async) {
        this._url = url;
        this._method = method;
        this._requestStartTime = Date.now();
        
        // Log all HLS-related requests for debugging
        if (typeof url === 'string' && (url.includes('.m3u8') || url.includes('.ts') || url.startsWith('blob:'))) {
            log(`🔍 XHR ${method} Request: ${url}`);
        }
        
        // Add more detailed tracking for segment requests
        if (typeof url === 'string' && url.includes('.ts')) {
            this._isMediaSegment = true;
            
            // Extract the segment name from the URL
            const urlParts = url.split('/');
            const segmentName = urlParts[urlParts.length - 1];
            this._segmentName = segmentName;
            log(`🎯 Intercepted XHR for segment: ${segmentName}`);

            // Check if the segment is in our map
            if (window.blobUrlMap && window.blobUrlMap.has(segmentName)) {
                log(`✅ Segment found in blob map: ${segmentName}`);
            } else {
                log(`⚠️ Segment NOT found in blob map: ${segmentName}`);
                
                if (window.blobUrlMap) {
                    const segmentKeys = Array.from(window.blobUrlMap.keys())
                        .filter(k => k.includes('.ts'))
                        .slice(0, 5); // Show first 5 to avoid log spam

                    log(`🔍 Available segments (first 5): ${segmentKeys.join(', ')}${
                        window.blobUrlMap.size > 5 ? ` (and ${window.blobUrlMap.size - 5} more)` : ''
                    }`);

                    // 🧹 Remove segments with invalid or suspiciously large IDs
                    const MAX_SAFE_ID = 100_000; // adjust if needed
                    for (const key of window.blobUrlMap.keys()) {
                        const match = key.match(/chunk-(\d+)\.ts/);
                        const id = match ? parseInt(match[1], 10) : null;

                        if (!Number.isFinite(id) || id < 0 || id > MAX_SAFE_ID) {
                            console.log(`🧹 Removing invalid segment key: ${key}`);
                            window.blobUrlMap.delete(key);
                        }
                    }
                }
            }
        }
        
        originalXHROpen.call(this, method, url, async !== false);
    };
    
    // Override send method to track responses
    XMLHttpRequest.prototype.send = function(body) {
        if (this._isMediaSegment || (typeof this._url === 'string' && this._url.includes('.m3u8'))) {
            const originalOnLoad = this.onload;
            const originalOnError = this.onerror;
            const url = this._url;
            const segmentName = this._segmentName;
            log(`🔍 XHR segment requested: ${segmentName}`);

            const startTime = this._requestStartTime;
            
            this.onload = function(e) {
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                if (this.status === 200) {
                    if (typeof url === 'string' && url.includes('.ts')) {
                        log(`✅ Segment loaded: ${segmentName || url} (${duration}ms, size: ${this.response?.byteLength || 0} bytes)`);
                    } else if (typeof url === 'string' && url.includes('.m3u8')) {
                        log(`✅ Manifest loaded: ${url} (${duration}ms)`);
                    }
                } else {
                    log(`❌ Failed to load: ${url} (${this.status})`);
                }
                
                if (originalOnLoad) originalOnLoad.call(this, e);
            };
            
            this.onerror = function(e) {
                log(`❌ Error loading: ${url}`);
                if (originalOnError) originalOnError.call(this, e);
            };
        }
        log(`📦 Attempting to serve: ${this._segmentName}`);
        originalXHRSend.call(this, body);
        
    };
    log(`🔍 Segment requested: ${segmentName}, found in blob map: ${blobUrlMap.has(segmentName)}`);

    log(`✅ Enhanced XHR debugging completed`);
    return true;
}

// Helper function to get amount of media buffered ahead of current position
function getBufferedAheadOf(buffered, position) {
    for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        
        if (position >= start && position < end) {
            return end - position;
        }
    }
    return 0;
}

/**
 * Simple logging function that outputs to both console and UI
 */
 function log(message) {
    const logEl = document.getElementById('logcatbox');
    if (!logEl) {
        console.log(message);
        return;
    }
    
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    
    // Handle multi-line messages (like M3U8 content)
    if (message.includes('\n')) {
        const lines = message.split('\n');
        const firstLine = `[${time}] ${lines[0]}`;
        logEl.value += firstLine + '\n';
        
        // Indent subsequent lines for better readability
        for (let i = 1; i < lines.length; i++) {
            logEl.value += `        ${lines[i]}\n`;
        }
    } else {
        const formattedMessage = `[${time}] ${message}`;
        logEl.value += formattedMessage + '\n';
    }
    
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}

/**
 * Updated listenToIncomingStreams function
 * - Assigns unique IDs to streams
 */
 async function listenToIncomingStreams(transport, packetHandler) {
    // Reset stream counter
    window.streamCounter = 0;
    
    try {
        console.log("🎧 Listening for incoming streams...");
        
        // Handle readable streams from the server
        const reader = transport.incomingUnidirectionalStreams.getReader();
        
        // Track active readers for cleanup
        window.activeReaders = [];
        
        while (!window.disconnectionRequested) {
            const { value: stream, done } = await reader.read();
            
            if (done) {
                console.log("📢 Server finished sending streams");
                break;
            }
            
            // Increment stream counter
            window.streamCounter++;
            
            // Update UI
            const streamCounter = document.getElementById('streamCounter');
            if (streamCounter) {
                streamCounter.textContent = window.streamCounter.toString();
            }
            
            // Handle this specific stream
            handleIncomingStream(stream, packetHandler);
        }
    } catch (error) {
        console.error(`❌ Error in stream listener: ${error.message}`);
        if (!window.disconnectionRequested) {
            // Only show error message if not intentionally disconnected
            handleConnectionClosed();
        }
    }
}

/**
 * Updated handleIncomingStream function
 * - Creates a dedicated buffer for each stream
 * - Extracts packets directly to the packet handler
 */
 async function handleIncomingStream(stream, packetHandler) {
    // Generate a unique ID for this stream
    const streamId = window.streamCounter || 0;
    
    // Create a dedicated reader for this stream
    const reader = stream.getReader();
    window.activeReaders.push(reader);
    
    // Create a dedicated buffer manager for this stream
    const streamBuffer = new WebTransportStreamBuffer(streamId);
    
    try {
        console.log(`📥 Processing incoming stream #${streamId}`);
        
        while (!window.disconnectionRequested) {
            const { value, done } = await reader.read();
            
            if (done) {
                console.log(`📤 Stream #${streamId} ended`);
                break;
            }
            
            if (!value || value.byteLength === 0) {
                continue;
            }
            
            // Add this chunk to the stream's buffer
            streamBuffer.addChunk(value);
            
            // Extract and process any complete packets
            let packet;
            while ((packet = streamBuffer.extractPacket()) !== null) {
                // Process the packet directly with the handler
                packetHandler.processValidatedPacket(packet);
                
                // Update UI counter
                document.getElementById('packetCounter').textContent = 
                    packetHandler.packetsReceived.toString();
            }
            
            // Periodically log buffer stats
            if (packetHandler.packetsReceived % 50 === 0) {
                const stats = streamBuffer.getStats();
                console.log(`📊 Stream #${streamId} buffer stats: Size=${stats.bufferSize}B, Valid=${stats.validPacketsExtracted}, Invalid=${stats.invalidPacketsRejected}`);
            }
        }
    } catch (error) {
        console.error(`❌ Error in stream #${streamId}: ${error.message}`);
    } finally {
        try {
            reader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
        
        const index = window.activeReaders.indexOf(reader);
        if (index !== -1) {
            window.activeReaders.splice(index, 1);
        }
        
        console.log(`🛑 Stream #${streamId} processing completed`);
    }
}

/**
 * Handle connection close events with enhanced cleanup
 */
 function handleConnectionClosed() {
    log("🛑 Connection closed");
    
    // Clear our maintenance interval
    if (window.partialPacketInterval) {
        clearInterval(window.partialPacketInterval);
        window.partialPacketInterval = null;
    }
    
    // Update UI
    document.getElementById('connectionStatus').textContent = "Disconnected";
    document.getElementById('connectionStatus').className = "status-badge status-disconnected";
    
    // Re-enable connect button
    document.getElementById('connectButton').disabled = false;
    document.getElementById('playButton').disabled = true;
    document.getElementById('disconnectButton').disabled = true;
    
    // Stop status updates
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
        window.statusInterval = null;
    }
    
    // Clean up readers
    window.activeReaders.forEach(reader => {
        try { reader.releaseLock(); } catch (e) { /* Ignore */ }
    });
    window.activeReaders = [];
    
    // Stop video playback
    if (window.player) {
        try {
            window.player.destroy();
        } catch (e) {
            log(`⚠️ Error destroying player: ${e.message}`);
        }
        window.player = null;
    }
    
    // Reset packet handler
    if (window.packetHandler) {
        try {
            window.packetHandler.disconnect();
        } catch (e) {
            log(`⚠️ Error disconnecting packet handler: ${e.message}`);
        }
        window.packetHandler = null;
    }
    
    // Reset transport
    if (window.transport) {
        try {
            window.transport.close();
        } catch (e) {
            log(`⚠️ Error closing transport: ${e.message}`);
        }
        window.transport = null;
    }
    
    window.playerState = 'idle';
    updateUI();
}

function updateUI() {
    // Update connection status
    const connectionStatus = document.getElementById('connectionStatus');
    if (connectionStatus) {
        connectionStatus.textContent = window.transport ? "Connected" : "Disconnected";
        connectionStatus.className = window.transport ? 
            "status-badge status-connected" : "status-badge status-disconnected";
    }
    
    // Update button states
    const connectButton = document.getElementById('connectButton');
    if (connectButton) {
        connectButton.disabled = !!window.transport;
    }
    
    const disconnectButton = document.getElementById('disconnectButton');
    if (disconnectButton) {
        disconnectButton.disabled = !window.transport;
    }
    
    const playButton = document.getElementById('playButton');
    if (playButton) {
        // Enable play if we have a player that's ready
        playButton.disabled = !(window.player && (window.playerState === 'ready' || window.playerState === 'paused'));
    }
    
    // Update player status
    const playerStatus = document.getElementById('playerStatus');
    if (playerStatus) {
        switch (window.playerState) {
            case 'playing':
                playerStatus.textContent = "Playing";
                playerStatus.className = "status-badge status-connected";
                break;
            case 'paused':
                playerStatus.textContent = "Paused";
                playerStatus.className = "status-badge";
                break;
            case 'buffering':
                playerStatus.textContent = "Buffering";
                playerStatus.className = "status-badge status-buffering";
                break;
            case 'error':
                playerStatus.textContent = "Error";
                playerStatus.className = "status-badge status-disconnected";
                break;
            case 'ready':
                playerStatus.textContent = "Ready";
                playerStatus.className = "status-badge";
                break;
            case 'loading':
                playerStatus.textContent = "Loading";
                playerStatus.className = "status-badge status-buffering";
                break;
            case 'attached':
                playerStatus.textContent = "Attached";
                playerStatus.className = "status-badge";
                break;
            default:
                playerStatus.textContent = "Idle";
                playerStatus.className = "status-badge";
        }
    }
    
    // Update buffer status if available
    const bufferStatus = document.getElementById('bufferStatus');
    if (bufferStatus) {
        // Use the global fragment counter
        bufferStatus.textContent = `${fragmentCounter} fragments`;
    }
    
    // Update stream counter
    const streamCounter = document.getElementById('streamCounter');
    if (streamCounter) {
        streamCounter.textContent = window.streamCounter ? window.streamCounter.toString() : "0";
    }
    
    // Update packet counter
    if (window.packetHandler) {
        const packetCounter = document.getElementById('packetCounter');
        if (packetCounter) {
            packetCounter.textContent = window.packetHandler.packetsReceived.toString();
        }
    }
}

/**
 * Start periodic status updates
 */
function startStatusUpdates() {
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
    }
    
    window.statusInterval = setInterval(() => {
        updateUI();
    }, 1000);
}

// Set up event listeners for buttons
document.addEventListener('DOMContentLoaded', function() {
    // Connect button
    document.getElementById('connectButton').addEventListener('click', async function() {
        try {
            const url = document.getElementById('wtUrl').value;
            
            if (!url || !url.startsWith('https://')) {
                alert('Please enter a valid HTTPS WebTransport URL');
                return;
            }
            
            // Disable connect button while connecting
            this.disabled = true;
            log(`🔗 Connecting to ${url}...`);
            
            // Update UI to show connection in progress
            document.getElementById('connectionStatus').textContent = "Connecting...";
            
            // Attempt to setup WebTransport connection
            await setupWebTransport(url);
            
            // Update connection status
            document.getElementById('connectionStatus').textContent = "Connected";
            document.getElementById('connectionStatus').className = "status-badge status-connected";
            
            // Enable disconnect button
            document.getElementById('disconnectButton').disabled = false;
            
        } catch (error) {
            log(`❌ Connection failed: ${error.message}`);
            this.disabled = false;
            document.getElementById('connectionStatus').textContent = "Failed";
            document.getElementById('connectionStatus').className = "status-badge status-disconnected";
        }
    });
    
    // Play button
    document.getElementById('playButton').addEventListener('click', function() {
        if (window.player) {
            const videoElement = document.getElementById('videoElement');
            videoElement.play().catch(err => {
                log(`❌ Error playing: ${err.message}`);
            });
            log(`▶️ Playing video`);
        } else {
            log(`⚠️ Player not initialized yet`);
        }
    });
    
    // Disconnect button
    document.getElementById('disconnectButton').addEventListener('click', function() {
        window.disconnectionRequested = true;
        log(`🔌 Disconnecting...`);
        
        handleConnectionClosed();

        if (window.hls) {
            window.hls.destroy();
            window.hls = null;
        }

        const video = document.getElementById('videoElement');
        video.pause();
        video.src = '';
        video.load();

        log("🛑 Playback and stream processing stopped.");

        window.blobUrlMap.clear();

    });
    
    // Initialize UI
    updateUI();
    updatePlayButton();
    log(`🚀 Player initialized and ready`);
});
    </script>
</body>
</html>