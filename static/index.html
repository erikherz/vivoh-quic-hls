<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <link rel="icon" href="data:;base64,=">
    <title>Vivoh WebTransport HLS Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .mainContainer {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .url-input {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .video-container {
            margin: 20px 0;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .video-logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100px;
            opacity: 0.8;
        }
        .centeredVideo {
            width: 100%;
            margin: 0 auto;
            display: block;
        }
        .logcatBox {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            background: #f8f9fa;
            height: 200px;
            overflow-y: auto;
            text-align: left;
            margin-top: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .btn {
            background-color: #1e88e5;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #1565c0;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"] {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            width: 80%;
            font-size: 16px;
        }
        label {
            font-weight: bold;
            white-space: nowrap;
        }
        .status-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-label {
            font-weight: bold;
        }
        .status-badge {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 14px;
        }
        .status-connected {
            background-color: #4caf50;
            color: white;
        }
        .status-disconnected {
            background-color: #f44336;
            color: white;
        }
        .status-buffering {
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <div class="mainContainer">
        <img src="vivoh.png" class="video-logo" alt="Video Logo">
        <div class="url-input">
            <label for="wtUrl">WebTransport URL:</label>
            <input id="wtUrl" type="text" value="https://va01.wtmpeg.com/live" style="width: 70%; padding: 10px;">
        </div>
        <div class="video-container">
            <video id="videoElement" class="centeredVideo" controls playsinline>
                Your browser is too old which doesn't support HTML5 video.
            </video>
        </div>
        <div class="status-container">
            <div class="status-indicator">
                <span class="status-label">Connection:</span>
                <span id="connectionStatus" class="status-badge status-disconnected">Disconnected</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">HLS Fragments:</span>
                <span id="bufferStatus" class="status-badge">0 fragments</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Player:</span>
                <span id="playerStatus" class="status-badge">Idle</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">QUIC Streams:</span>
                <span id="streamCounter" class="status-badge">0</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Media Packets:</span>
                <span id="packetCounter" class="status-badge">0</span>
            </div>
        </div>
        <div class="controls">
            <button id="connectButton" class="btn">Connect</button>
            <button id="playButton" class="btn" disabled>Play</button>
            <button id="disconnectButton" class="btn" disabled>Disconnect</button>
        </div>
        <textarea id="logcatbox" class="logcatBox" rows="10" readonly></textarea>
    </div>

    <script src="hls.js"></script>
    <script>


// Global variables
let transport = null;
let packetHandler = null;
let statusInterval = null;
let player = null;
let playerState = 'idle';
let disconnectionRequested = false;
let activeReaders = [];
let xhrInterceptionEnabled = false;
let streamCounter = 0;
let bufferLoggingIntervals = [];
window.blobUrlMap = new Map();
let masterPlaylistUrl = null;
let videoPlaylistUrl = null;

window.registerMediaSegment = (trackId, segmentId, data, segmentName) => {
    // Store with both the exact name and the ID-based key
    window.blobUrlMap.set(segmentName, data);
    window.blobUrlMap.set(`segment-${trackId}-${segmentId}`, data);
    log(`üîó Registered segment: ${segmentName}`);
};

/**
 * WebTransportHLSPacketHandler class
 * 
 * Processes incoming media data from WebTransport and makes it available for HLS.js
 */
class WebTransportHLSPacketHandler {
    constructor() {
        // Media buffers by track type
        this.buffer = {
            video: {}, // Map of packetId -> fragment data
            audio: {}  // Map of packetId -> fragment data
        };
        
        // Initialization segments
        this.init = {
            video: null,
            audio: null
        };
        
        // HLS manifest content
        this.hlsData = null;
        this.hlsUrl = '/vivoh.m3u8';
        
        // Track-specific buffers with metadata
        this.trackBuffers = {
            0: {  // Video track
                fragments: [],
                lastSequence: -1
            },
            1: {  // Audio track
                fragments: [],
                lastSequence: -1
            }
        };
        
        // Statistics and state
        this.bytesReceived = 0;
        this.fragmentsReceived = 0;
        this.packetsReceived = 0;
        this.lastProcessedPacketId = -1;
        this.isDisconnected = false;
        
        // Event callback
        this.onHLSReady = null;
    }
    
    /**
     * Process a WebTransport Media Packet
     * 
     * @param {Uint8Array|ArrayBuffer} data - The packet data
     * @returns {boolean} - Whether processing was successful
     */
    processWMPPacket(data) {
        try {
            // Convert data to Uint8Array if needed
            const dataArray = this._ensureUint8Array(data);
            
            // Validate minimum packet size (20 bytes for header)
            if (dataArray.length < 20) {
                log(`‚ö†Ô∏è Packet too small: ${dataArray.length} bytes (minimum 20 required)`);
                return false;
            }
            
            // Parse the header according to WebTransportMediaPacket structure
            const view = new DataView(dataArray.buffer, dataArray.byteOffset, dataArray.byteLength);
            const packetId = view.getUint32(0);          // 4 bytes: u32
            const timestamp = view.getBigUint64(4);      // 8 bytes: u64
            const duration = view.getUint32(12);         // 4 bytes: u32
            const segmentDuration = view.getFloat32(16); // 4 bytes: f32
            
            // The AV data starts at byte 20
            const avData = dataArray.slice(20);
            
            // Check for duplicate packets
            if (packetId === this.lastProcessedPacketId) {
                log(`üîÑ Duplicate packet ID: ${packetId}, ignoring`);
                return true;
            }
            
            // Update tracking stats
            this.lastProcessedPacketId = packetId;
            this.packetsReceived++;
            
            // For MPEG-TS streams, we don't need initialization segments
            // Process the AV data directly as a video fragment
            if (avData.byteLength > 0) {
                this._processMediaFragment(0, packetId, avData, true, segmentDuration);
            }
            
            // Log periodic stats
            if (this.packetsReceived % 10 === 0) {
                const tsSeconds = Number(timestamp) / 1000000; // Convert microseconds to seconds
                log(`üìà Packet stats: Received=${this.packetsReceived}, ` +
                    `TS=${tsSeconds.toFixed(3)}s, Duration=${duration}ms, SegDuration=${segmentDuration}s, ` +
                    `Buffer size: V=${Object.keys(this.buffer.video).length}, ` +
                    `A=${Object.keys(this.buffer.audio).length}`);
            }
            
            // Update stats
            this.fragmentsReceived++;
            this.bytesReceived += dataArray.byteLength;
            
            // Check if we have enough data to start playback
            this._checkPlaybackReadiness();

            // Generate manifest after receiving a few packets if we don't have one yet
            if (!this.hlsData && this.packetsReceived >= 3) {
                this._generateHLSManifest();
            }
            
            return true;
        } catch (error) {
            log(`‚ùå Error processing packet: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Convert incoming data to Uint8Array
     * 
     * @param {Uint8Array|ArrayBuffer|object} data - The input data
     * @returns {Uint8Array} - Normalized data as Uint8Array
     * @private
     */
    _ensureUint8Array(data) {
        if (data instanceof ArrayBuffer) {
            return new Uint8Array(data);
        } else if (data instanceof Uint8Array) {
            return data;
        } else if (data && typeof data === 'object' && 'buffer' in data) {
            // Handle Node.js Buffer or similar buffer-view objects
            return new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength);
        } else {
            throw new Error(`Invalid data type for packet: ${typeof data}`);
        }
    }
}

WebTransportHLSPacketHandler.prototype._extractPacketHeader = function(dataArray) {
    const view = new DataView(dataArray.buffer, dataArray.byteOffset, dataArray.byteLength);
    
    // Extract fields according to WebTransportMediaPacket structure
    const packetId = view.getUint32(0);           // 4 bytes: u32
    const timestamp = view.getBigUint64(4);       // 8 bytes: u64
    const duration = view.getUint32(12);          // 4 bytes: u32
    const segmentDuration = view.getFloat32(16);  // 4 bytes: f32
    
    // The AV data starts at byte 20
    const avData = dataArray.slice(20);
    
    // Check if this is a MPEG-TS packet (should start with 0x47 sync byte)
    const isMpegTs = avData.byteLength > 0 && avData[0] === 0x47;
    
    return {
        packetId,
        timestamp,
        duration,
        segmentDuration,
        isMpegTs,
        mediaData: avData
    };
};

WebTransportHLSPacketHandler.prototype._processHLSData = function(data) {
    if (data.byteLength === 0) return;
    
    try {
        // Convert the binary data to a string
        const hlsString = new TextDecoder().decode(data);
        
        // Check if this is an actual HLS manifest
        if (hlsString.includes('#EXTM3U')) {
            this.hlsData = hlsString;
            log(`üìÑ Extracted HLS manifest (${data.byteLength} bytes)`);
        } else {
            // If it's not a valid HLS manifest, we'll need to generate one
            log(`‚ö†Ô∏è MPD field doesn't contain a valid HLS manifest`);
            this._generateHLSManifest();
            return;
        }
        
        // Create a Blob URL for the HLS if needed
        if (typeof URL !== 'undefined' && URL.createObjectURL) {
            const blob = new Blob([this.hlsData], { type: 'application/vnd.apple.mpegurl' });
            this.hlsUrl = URL.createObjectURL(blob);
            log(`üîó Created HLS blob URL: ${this.hlsUrl}`);
            
            // Register the HLS blob URL 
            if (typeof window.registerManifestBlobUrl === 'function') {
                window.registerManifestBlobUrl(this.hlsUrl, this.hlsData);
            }
        }
        
        // Notify that the HLS is ready
        if (typeof this.onHLSReady === 'function') {
            this.onHLSReady(this.hlsUrl);
        }
    } catch (error) {
        log(`‚ùå Error processing HLS data: ${error.message}`);
    }
};

WebTransportHLSPacketHandler.prototype._generateHLSManifest = function() {
    // Create a basic master playlist
    let masterPlaylist = '#EXTM3U\n';
    masterPlaylist += '#EXT-X-VERSION:3\n';
    
    // Create a video media playlist
    let videoPlaylist = '#EXTM3U\n';
    videoPlaylist += '#EXT-X-VERSION:3\n';
    videoPlaylist += '#EXT-X-TARGETDURATION:1\n'; // Match ffmpeg -hls_time 1
    videoPlaylist += '#EXT-X-MEDIA-SEQUENCE:0\n';
    
    // Add segment entries for video
    const videoSegments = Object.keys(this.buffer.video)
        .map(Number)
        .sort((a, b) => a - b);
    
    if (videoSegments.length === 0) {
        // Add a dummy segment if no segments are available yet
        videoPlaylist += '#EXTINF:1.0,\n';
        videoPlaylist += 'chunk-00000.ts\n'; // Match ffmpeg naming pattern
    } else {
        for (let i = 0; i < videoSegments.length; i++) {
            const segId = videoSegments[i];
            // Use segmentDuration if available, otherwise default to 1.0
            const segDuration = this.trackBuffers[0].fragments.find(f => f.sequence === segId)?.segmentDuration || 1.0;
            videoPlaylist += `#EXTINF:${segDuration.toFixed(3)},\n`;
            
            // FIX: Always use the original segment ID in the manifest
            // This ensures consistency between manifest entries and XHR requests
            const segmentName = `chunk-${segId.toString().padStart(5, '0')}.ts`;
            videoPlaylist += `${segmentName}\n`;
            
            // Register segment with consistent naming
            window.registerMediaSegment(0, segId, this.buffer.video[segId], segmentName);
        }
        
        if (this.isDisconnected) {
            videoPlaylist += '#EXT-X-ENDLIST\n';
        }
    }
    
    // Log full video playlist content to both console and UI
    console.log("GENERATED VIDEO PLAYLIST:", videoPlaylist);
    log(`üìÑ VIDEO PLAYLIST CONTENT:\n${videoPlaylist}`);
    
    // FIX: Only create new Blob URLs if they don't exist yet
    // This provides stable URLs for HLS.js to work with
    const videoBlob = new Blob([videoPlaylist], { type: 'application/vnd.apple.mpegurl' });
    if (!videoPlaylistUrl) {
        videoPlaylistUrl = URL.createObjectURL(videoBlob);
        log(`üîó Created new video playlist URL: ${videoPlaylistUrl}`);
    } else {
        // Just update the map without changing URL
        log(`üîÑ Updating existing video playlist URL: ${videoPlaylistUrl}`);
    }
    
    // Now reference the video playlist URL in the master playlist
    masterPlaylist += `#EXT-X-STREAM-INF:BANDWIDTH=3000000,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2"\n`;
    masterPlaylist += `${videoPlaylistUrl}\n`;
    
    // Log full master playlist content to both console and UI
    console.log("GENERATED MASTER PLAYLIST:", masterPlaylist);
    log(`üìÑ MASTER PLAYLIST CONTENT:\n${masterPlaylist}`);
    
    // FIX: Only create new master Blob URL if it doesn't exist yet
    const masterBlob = new Blob([masterPlaylist], { type: 'application/vnd.apple.mpegurl' });
    if (!masterPlaylistUrl) {
        masterPlaylistUrl = URL.createObjectURL(masterBlob);
        this.hlsUrl = masterPlaylistUrl;
        log(`üîó Created new master playlist URL: ${masterPlaylistUrl}`);
    } else {
        // Just update the map without changing URL
        this.hlsUrl = masterPlaylistUrl;
        log(`üîÑ Updating existing master playlist URL: ${masterPlaylistUrl}`);
    }
    
    // Make sure blobUrlMap is defined globally
    if (!window.blobUrlMap) {
        window.blobUrlMap = new Map();
    }
    
    // Register all playlists for XHR interception
    window.blobUrlMap.set(this.hlsUrl, masterPlaylist);
    window.blobUrlMap.set(videoPlaylistUrl, videoPlaylist);
    
    // Also use the registerManifestBlobUrl function if available
    if (typeof window.registerManifestBlobUrl === 'function') {
        window.registerManifestBlobUrl(this.hlsUrl, masterPlaylist);
        window.registerManifestBlobUrl(videoPlaylistUrl, videoPlaylist);
    }
    
    log(`‚úÖ Generated HLS manifests and registered blob URLs: Master=${this.hlsUrl}, Video=${videoPlaylistUrl}`);
    
    // Notify that the HLS is ready
    if (typeof this.onHLSReady === 'function') {
        this.onHLSReady(this.hlsUrl);
    }
};

WebTransportHLSPacketHandler.prototype._updateHLSManifest = function() {
    // Only update occasionally to avoid excessive regeneration
    if (Math.random() > 0.2) return; // Only update ~20% of the time
    
    // Generate new manifests with updated segment lists
    this._generateHLSManifest();
    log(`üîÑ Updated HLS manifests with new fragments`);
};

WebTransportHLSPacketHandler.prototype._processMediaFragment = function(trackId, packetId, mediaData, isVideo, segmentDuration = 1.0) {
    const trackType = isVideo ? "video" : "audio";
    
    // Skip empty fragments
    if (mediaData.byteLength === 0) {
        return;
    }
    
    // Ensure segmentDuration is a valid number
    if (isNaN(segmentDuration) || !isFinite(segmentDuration) || segmentDuration <= 0) {
        // Default to 1.0 second if the duration is invalid
        segmentDuration = 1.0;
        log(`‚ö†Ô∏è Invalid segment duration for ${trackType} #${packetId}, using default: 1.0`);
    }
    
    // Cap segment duration to reasonable values (between 0.1 and 10 seconds)
    segmentDuration = Math.max(0.1, Math.min(10.0, segmentDuration));
    
    // MPEG-TS detection - check for sync byte 0x47 ('G' in ASCII)
    const isMpegTs = mediaData.byteLength > 0 && mediaData[0] === 0x47;
    
    if (isMpegTs) {
        log(`üß© Detected MPEG-TS packet for ${trackType} #${packetId}`);
        
        // Check for multiple TS packets (each should be 188 bytes)
        if (mediaData.byteLength >= 188) {
            const packetCount = Math.floor(mediaData.byteLength / 188);
            if (packetId % 10 === 0) {
                log(`üìä Contains ${packetCount} TS packets, total size=${mediaData.byteLength}B`);
            }
        }
    } else if (mediaData.byteLength >= 8) {
        // Not a TS packet, but log what we received
        try {
            const boxType = String.fromCharCode(
                mediaData[4], mediaData[5], mediaData[6], mediaData[7]
            );
            
            if (packetId % 10 === 0) {
                log(`üß™ Fragment ${packetId} (${trackType}) starts with box: ${boxType}`);
            }
        } catch (e) {
            // If we can't extract box type, just log packet type
            log(`üì¶ Non-TS fragment ${packetId} received`);
        }
    }
    
    // FIX: Use a consistent naming approach for all segments
    // Generate the segment name based on original packetId
    const segmentName = `chunk-${packetId.toString().padStart(5, '0')}.ts`;
    
    // Store both the original data and normalized segment info
    this.buffer[trackType][packetId] = mediaData;
    
    // Add to track-specific buffers
    if (!this.trackBuffers[trackId]) {
        this.trackBuffers[trackId] = { fragments: [], lastSequence: -1 };
    }
    
    // Add to fragments array with sequence info and segment duration
    this.trackBuffers[trackId].fragments.push({
        sequence: packetId,
        data: mediaData,
        isKeyframe: true, // For MPEG-TS segments, treat all as keyframes
        timestamp: Date.now(),
        isMpegTs: isMpegTs,
        segmentDuration: segmentDuration, // Store segment duration from packet
        segmentName: segmentName  // Store the segment name
    });
    
    // FIX: Register the media segment with consistent names
    if (typeof window.registerMediaSegment === 'function') {
        // Register with the formatted segment name
        window.registerMediaSegment(trackId, packetId, mediaData, segmentName);
        
        // Also register with a simpler name for legacy support
        const simpleName = `chunk-${packetId}.ts`;
        if (simpleName !== segmentName) {
            window.registerMediaSegment(trackId, packetId, mediaData, simpleName);
        }
    }
    
    // Log fragment details
    if (isVideo && packetId % 10 === 0) {
        log(`üì¶ ${trackType} fragment #${packetId} processed, size=${mediaData.byteLength}B, duration=${segmentDuration.toFixed(3)}s, name=${segmentName}`);
    }
    
    // Keep buffer size reasonable (keep last 30 fragments)
    if (this.trackBuffers[trackId].fragments.length > 30) {
        this.trackBuffers[trackId].fragments.sort((a, b) => {
            // Sort by sequence ID (equivalent to original packetId)
            return a.sequence - b.sequence;
        });
        
        this.trackBuffers[trackId].fragments = this.trackBuffers[trackId].fragments.slice(-30);
        
        // Also clean up main buffer, but be selective about which keys to remove
        const keysToKeep = this.trackBuffers[trackId].fragments.map(f => f.sequence);
        const keysToRemove = Object.keys(this.buffer[trackType])
            .map(Number)
            .filter(key => !keysToKeep.includes(key));
            
        for (const key of keysToRemove) {
            delete this.buffer[trackType][key];
        }
    }
    
    // Update last sequence
    this.trackBuffers[trackId].lastSequence = Math.max(
        this.trackBuffers[trackId].lastSequence, 
        packetId
    );
    
    // Update HLS manifest if needed
    this._updateHLSManifest();
};

/**
 * WebTransport HLS.js Player - Part 3: HLS.js Integration
 */

WebTransportHLSPacketHandler.prototype._checkPlaybackReadiness = function() {
    // If player already exists, don't create another one
    if (window.player) {
        return;
    }
    
    // Check if we have initialization segments and HLS data
    const hasVideoInit = this.init.video !== null;
    const hasAudioInit = this.init.audio !== null;
    const hasHLS = this.hlsData !== null;
    
    // Check if we have enough fragments
    const videoCount = Object.keys(this.buffer.video).length;
    const audioCount = Object.keys(this.buffer.audio).length;
    
    // Wait until we have enough data to start playback
    if (hasVideoInit && hasAudioInit && hasHLS && videoCount >= 3 && audioCount >= 3) {
        log(`‚úÖ Media ready: HLS=${hasHLS}, V=${videoCount}/${hasVideoInit}, A=${audioCount}/${hasAudioInit}`);
        
        // Notify that we're ready to initialize the player
        if (typeof this.onHLSReady === 'function') {
            this.onHLSReady(this.hlsUrl);
        }
    } else if (!hasHLS && videoCount >= 3 && audioCount >= 3) {
        // We have enough fragments but no HLS manifest - generate one
        this._generateHLSManifest();
    }
};

WebTransportHLSPacketHandler.prototype.getFragment = function(trackId, segmentId) {
    const trackType = trackId === 0 ? "video" : "audio";
    
    // For initialization segments
    if (segmentId === 0 || segmentId === -1) {
        return this.init[trackType];
    }
    
    // For media segments
    const buffer = this.buffer[trackType];
    
    // Try to find exact segment ID
    if (buffer[segmentId]) {
        return buffer[segmentId];
    }
    
    // If not found, get closest segment ID
    const keys = Object.keys(buffer).map(Number).sort((a, b) => a - b);
    
    // Find closest segment (prefer newer segments)
    if (keys.length > 0) {
        // Sort by closeness to the requested segment ID
        keys.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId));
        const closestId = keys[0];
        
        log(`‚ö†Ô∏è Segment #${segmentId} not found, using closest #${closestId}`);
        return buffer[closestId];
    }
    
    return null;
};

WebTransportHLSPacketHandler.prototype.getStats = function() {
    const videoFragCount = Object.keys(this.buffer.video).length;
    const audioFragCount = Object.keys(this.buffer.audio).length;
    
    return {
        bytesReceived: this.bytesReceived,
        audioFragments: audioFragCount,
        videoFragments: videoFragCount,
        fragmentsReceived: this.fragmentsReceived,
        fragmentsAvailable: videoFragCount + audioFragCount,
        packetsReceived: this.packetsReceived,
        videoInitAvailable: this.init.video !== null,
        audioInitAvailable: this.init.audio !== null,
        hlsAvailable: this.hlsData !== null
    };
};

WebTransportHLSPacketHandler.prototype.disconnect = function() {
    this.isDisconnected = true;
    log(`üßπ Cleaning up packet handler resources`);
    
    // Clear buffers
    this.buffer.video = {};
    this.buffer.audio = {};
    
    // Clear track-specific buffers
    Object.keys(this.trackBuffers).forEach(trackId => {
        this.trackBuffers[trackId].fragments = [];
    });
    
    // FIX: Properly clean up all blob URLs
    if (masterPlaylistUrl) {
        try {
            URL.revokeObjectURL(masterPlaylistUrl);
            log(`üßπ Revoked master playlist URL: ${masterPlaylistUrl}`);
            masterPlaylistUrl = null;
        } catch (e) {
            log(`‚ö†Ô∏è Error revoking master playlist URL: ${e.message}`);
        }
    }
    
    if (videoPlaylistUrl) {
        try {
            URL.revokeObjectURL(videoPlaylistUrl);
            log(`üßπ Revoked video playlist URL: ${videoPlaylistUrl}`);
            videoPlaylistUrl = null;
        } catch (e) {
            log(`‚ö†Ô∏è Error revoking video playlist URL: ${e.message}`);
        }
    }
    
    // Clear HLS data
    this.hlsData = null;
    this.hlsUrl = '/vivoh.m3u8';
    
    // Clear initialization segments
    this.init.video = null;
    this.init.audio = null;
};

function enhanceXHRDebugging() {
    // Only run this if XHR interception is already enabled
    if (!window.xhrInterceptionEnabled) return;
    
    log("üîç Enhancing XMLHttpRequest debugging");
    
    // Store the original send method
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    // Override send method to add additional logging
    XMLHttpRequest.prototype.send = function(body) {
        // Log segment requests for debugging purposes
        if (this._isMediaSegment) {
            log(`üîç XHR REQUEST: Segment=${this._segmentName || "unknown"}, URL=${this._url}`);
            
            // Check if we have this segment registered
            if (window.blobUrlMap && this._segmentName) {
                const hasSegment = window.blobUrlMap.has(this._segmentName);
                log(`üîç Blob map has segment "${this._segmentName}": ${hasSegment}`);
                
                // If not found, log available segment names for debugging
                if (!hasSegment && window.blobUrlMap.size < 20) {
                    log(`üîç Available segments: ${Array.from(window.blobUrlMap.keys()).filter(k => k.includes('.ts')).join(', ')}`);
                }
            }
        }
        
        // Call the original send method
        return originalXHRSend.call(this, body);
    };
    
    log(`‚úÖ XHR debugging enhancement completed`);
    return true;
}

    /**
     * Set up XHR interception for HLS.js segment requests
     */
    function setupXHRInterception() {
        if (window.xhrInterceptionEnabled) return;
        
        log("üîÑ Setting up XMLHttpRequest interception for HLS");
        window.xhrInterceptionEnabled = true;
        
        const originalXHROpen = XMLHttpRequest.prototype.open;
        const originalXHRSend = XMLHttpRequest.prototype.send;
        
        // Create a map to store blob URLs and their corresponding data
        const blobUrlMap = new Map();
        
        // Add method to register manifest blob URLs
        window.registerManifestBlobUrl = (url, manifestData) => {
            blobUrlMap.set(url, manifestData);
            log(`üìÑ Registered manifest blob URL: ${url}`);
        };
        
        // Override open method to track request type
    // In setupXHRInterception(), update the XMLHttpRequest.prototype.open override:
    XMLHttpRequest.prototype.open = function(method, url, async) {
        this._url = url;
        this._method = method;
        
        if (method === 'GET' && typeof url === 'string') {
            log(`üîç XHR Request: ${method} ${url}`);
        }
        
        // Track request type with improved patterns
        if (typeof url === 'string') {
            // Blob URLs for manifests we've registered
            if (url.startsWith('blob:') && window.blobUrlMap && window.blobUrlMap.has(url)) {
                this._isManifestBlobUrl = true;
                log(`üìÑ Recognized manifest blob URL: ${url}`);
            }
            // HLS manifest (.m3u8) requests
            else if (url.includes('.m3u8') || url === 'video.m3u8' || url === 'playlist.m3u8') {
                this._isManifestRequest = true;
                log(`üìÑ HLS manifest request detected: ${url}`);
            } 
            else if (url.includes('.ts') || url.match(/chunk-\d+\.ts/)) {
                this._isMediaSegment = true;
                
                // Extract the exact segment name from the URL
                const urlParts = url.split('/');
                const segmentName = urlParts[urlParts.length - 1];
                
                // Store the segment name for later use
                this._segmentName = segmentName;
                
                // Try to extract segment ID from pattern
                const matchSegment = segmentName.match(/chunk-(\d+)\.ts/);
                if (matchSegment) {
                    this._segmentId = parseInt(matchSegment[1]);
                    this._trackId = 0; // Default to video track for TS segments
                    log(`üé¨ TS segment request: segment=${this._segmentId}, name=${segmentName}`);
                }
            }
        }
        
        originalXHROpen.call(this, method, url, async !== false);
    };
    
    // Override send method to serve content from our buffer
    XMLHttpRequest.prototype.send = function(body) {
        // External requests - always pass through
        if (this._isExternalRequest) {
            originalXHRSend.call(this, body);
            return;
        }
        
        // Manifest Blob URL Request - serve from our map
        if (this._isManifestBlobUrl && blobUrlMap.has(this._url)) {
            log(`üìÑ Serving registered manifest blob from map (${this._url})`);
            
            const manifestData = blobUrlMap.get(this._url);
            log(`üìÑ MANIFEST BLOB CONTENT:\n${manifestData}`);            
            
            setTimeout(() => {
                this.responseType = 'text';
                Object.defineProperty(this, 'response', { get: () => manifestData });
                Object.defineProperty(this, 'responseText', { get: () => manifestData });
                Object.defineProperty(this, 'status', { get: () => 200 });
                Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                Object.defineProperty(this, 'readyState', { get: () => 4 });
                
                this.dispatchEvent(new Event('readystatechange'));
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('loadend'));
                
                log(`‚úÖ Blob manifest served successfully`);
            }, 10);
            
            return;
        }
        
        // HLS Manifest Request
        if (this._isManifestRequest && window.packetHandler?.hlsData) {
            log(`üìÑ Serving HLS manifest from WebTransport packet (${window.packetHandler.hlsData.length} bytes)`);
            log(`üìÑ M3U8 CONTENT:\n${window.packetHandler.hlsData}`);
            
            setTimeout(() => {
                this.responseType = 'text';
                Object.defineProperty(this, 'response', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'responseText', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'status', { get: () => 200 });
                Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                Object.defineProperty(this, 'readyState', { get: () => 4 });
                
                this.dispatchEvent(new Event('readystatechange'));
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('loadend'));
                
                log(`‚úÖ HLS manifest served successfully`);
            }, 10);
            
            return;
        }
        
        // Init Segment Request
        if (this._isInitSegment && typeof this._trackId !== 'undefined') {
            const trackId = this._trackId;
            const trackType = trackId === 0 ? "video" : "audio";
            
            // Check if we have an init segment for this track
            if (window.packetHandler?.init[trackType]) {
                const initData = window.packetHandler.init[trackType];
                log(`üîë Serving ${trackType} init segment (${initData.byteLength} bytes)`);
                
                setTimeout(() => {
                    // Make sure we're using the correct responseType
                    this.responseType = 'arraybuffer';
                    
                    // Make sure we're serving an ArrayBuffer, not a TypedArray
                    let buffer;
                    if (initData instanceof Uint8Array) {
                        buffer = initData.buffer.slice(
                            initData.byteOffset, 
                            initData.byteOffset + initData.byteLength
                        );
                    } else {
                        buffer = initData;
                    }
                    
                    // Set the correct response properties
                    Object.defineProperty(this, 'response', { get: () => buffer });
                    Object.defineProperty(this, 'status', { get: () => 200 });
                    Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                    Object.defineProperty(this, 'readyState', { get: () => 4 });
                    
                    // Dispatch events to signal completion
                    this.dispatchEvent(new Event('readystatechange'));
                    this.dispatchEvent(new Event('load'));
                    this.dispatchEvent(new Event('loadend'));
                    
                    log(`‚úÖ Init segment served: track=${trackId}`);
                }, 10);
                
                return;
            } else {
                log(`‚ö†Ô∏è No init segment available for track ${trackId}`);
            }
        }
        
        if (this._isMediaSegment) {
            // First look for segments by name if available
            if (this._segmentName && window.blobUrlMap && window.blobUrlMap.has(this._segmentName)) {
                const segmentData = window.blobUrlMap.get(this._segmentName);
                serveSegmentData(this, segmentData, this._segmentName);
                return;
            }
            
            // Then try by ID if we have that
            if (this._trackId !== undefined && this._segmentId !== undefined && window.packetHandler) {
                const trackType = this._trackId === 0 ? "video" : "audio";
                if (window.packetHandler.buffer[trackType][this._segmentId]) {
                    const segmentData = window.packetHandler.buffer[trackType][this._segmentId];
                    serveSegmentData(this, segmentData, `segment-${this._trackId}-${this._segmentId}`);
                    return;
                }
            }
            
            // No segment found, respond with 404
            log(`‚ö†Ô∏è No media segment found for: ${this._segmentName || this._url}`);
            respondWith404(this);
            return;
        }
        
        // Fall back to original XHR behavior for any unhandled requests
        originalXHRSend.call(this, body);
    };
    
    log(`‚úÖ XHR interception setup completed for HLS.js`);
    return true;
}

// Helper function to serve segment data
function serveSegmentData(xhr, data, segmentName) {
    log(`üé¨ Serving segment: ${segmentName} (${data.byteLength} bytes)`);
    
    setTimeout(() => {
        xhr.responseType = 'arraybuffer';
        let buffer;
        if (data instanceof Uint8Array) {
            buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
        } else {
            buffer = data;
        }
        
        Object.defineProperty(xhr, 'response', { get: () => buffer });
        Object.defineProperty(xhr, 'status', { get: () => 200 });
        Object.defineProperty(xhr, 'statusText', { get: () => 'OK' });
        Object.defineProperty(xhr, 'readyState', { get: () => 4 });
        
        xhr.dispatchEvent(new Event('readystatechange'));
        xhr.dispatchEvent(new Event('load'));
        xhr.dispatchEvent(new Event('loadend'));
        
        log(`‚úÖ Media segment served: ${segmentName}`);
    }, 10);
}

// Helper function to respond with 404
function respondWith404(xhr) {
    setTimeout(() => {
        Object.defineProperty(xhr, 'status', { get: () => 404 });
        Object.defineProperty(xhr, 'statusText', { get: () => 'Not Found' });
        Object.defineProperty(xhr, 'readyState', { get: () => 4 });
        
        xhr.dispatchEvent(new Event('readystatechange'));
        xhr.dispatchEvent(new Event('load'));
        xhr.dispatchEvent(new Event('loadend'));
    }, 10);
}

function enhanceXHRInterception() {
    // Only run this if XHR interception is already enabled
    if (!window.xhrInterceptionEnabled) return;
    
    log("üîß Enhancing XMLHttpRequest interception for HLS");
    
    // Store the original open and send methods
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    // Override open method with improved URL pattern detection
    XMLHttpRequest.prototype.open = function(method, url, async) {
        this._url = url;
        this._method = method;
        
        if (method === 'GET' && typeof url === 'string') {
            if (url.includes('debug')) {
                log(`üîç XHR Request: ${method} ${url}`);
            }
        }
        
        // Track request type with improved patterns
        if (typeof url === 'string') {
            // Blob URLs for manifests we've registered
            if (url.startsWith('blob:') && window.blobUrlMap && window.blobUrlMap.has(url)) {
                this._isManifestBlobUrl = true;
                log(`üìÑ Recognized manifest blob URL: ${url}`);
            }
            // HLS manifest (.m3u8) requests - broader pattern matching
            else if (url.includes('.m3u8') || url === 'video.m3u8' || url === 'audio.m3u8') {
                this._isManifestRequest = true;
                log(`üìÑ HLS manifest request detected: ${url}`);
                
                // Store specific manifest type
                if (url.includes('video')) {
                    this._manifestType = 'video';
                } else if (url.includes('audio')) {
                    this._manifestType = 'audio';
                } else {
                    this._manifestType = 'master';
                }
            } 
            // Init segment requests with more patterns
            else if (url.includes('init') || url.includes('init.mp4') || url.includes('chunk_0_init.m4s')) {
                this._isInitSegment = true;
                
                // Extract track ID from URL pattern
                const matchTrack = url.match(/chunk_(\d+)_init/) || url.match(/init[_-](\d+)/);
                if (matchTrack) {
                    this._trackId = parseInt(matchTrack[1]);
                    log(`üîë Init segment request for track ${this._trackId}`);
                } else {
                    // Default to video track if pattern doesn't match
                    this._trackId = 0;
                    log(`üîë Init segment request defaulting to video track`);
                }
            } 
            // Media segment requests with more patterns
            else if (url.match(/chunk[_-]\d+[_-]\d+\.m4s/) || url.match(/segment[_-]\d+[_-]\d+/)) {
                this._isMediaSegment = true;
                
                // Extract track and segment IDs from various URL patterns
                let matchSegment = url.match(/chunk[_-](\d+)[_-](\d+)\.m4s/) || 
                                  url.match(/segment[_-](\d+)[_-](\d+)/);
                
                if (matchSegment) {
                    this._trackId = parseInt(matchSegment[1]);
                    this._segmentId = parseInt(matchSegment[2]);
                    log(`üé¨ Media segment request: track=${this._trackId}, segment=${this._segmentId}`);
                }
            }
        }
        
        originalXHROpen.call(this, method, url, async !== false);
    };
    
    // Enhance send method to better handle manifest requests
    XMLHttpRequest.prototype.send = function(body) {
        if (this._isManifestRequest && window.packetHandler?.hlsData) {
            log(`üìÑ Serving HLS manifest from WebTransport packet`);

            log(`üìÑ M3U8 CONTENT BEING SERVED:\n${window.packetHandler.hlsData}`);
            console.log("M3U8 CONTENT BEING SERVED:", window.packetHandler.hlsData);
            
            setTimeout(() => {
                this.responseType = 'text';
                Object.defineProperty(this, 'response', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'responseText', { get: () => window.packetHandler.hlsData });
                Object.defineProperty(this, 'status', { get: () => 200 });
                Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                Object.defineProperty(this, 'readyState', { get: () => 4 });
                
                this.dispatchEvent(new Event('readystatechange'));
                this.dispatchEvent(new Event('load'));
                this.dispatchEvent(new Event('loadend'));
                
                log(`‚úÖ HLS manifest served successfully`);
            }, 10);
            
            return;
        }

        // For requests we're not handling in our enhanced version, call the original implementation
        originalXHRSend.call(this, body);
    };
    
    if (this._isManifestBlobUrl && blobUrlMap.has(this._url)) {
        log(`üìÑ Serving registered manifest blob from map (${this._url})`);
        
        const manifestData = blobUrlMap.get(this._url);
        log(`üìÑ M3U8 BLOB CONTENT BEING SERVED:\n${manifestData}`);
        console.log("M3U8 BLOB CONTENT BEING SERVED:", manifestData);    
    
    setTimeout(() => {
            this.responseType = 'text';
            Object.defineProperty(this, 'response', { get: () => manifestData });
            Object.defineProperty(this, 'responseText', { get: () => manifestData });
            Object.defineProperty(this, 'status', { get: () => 200 });
            Object.defineProperty(this, 'statusText', { get: () => 'OK' });
            Object.defineProperty(this, 'readyState', { get: () => 4 });
            
            this.dispatchEvent(new Event('readystatechange'));
            this.dispatchEvent(new Event('load'));
            this.dispatchEvent(new Event('loadend'));
            
            log(`‚úÖ Blob manifest served successfully`);
        }, 10);
        
        return;
    }
    log(`‚úÖ Enhanced XHR interception setup completed`);
    return true;
}

// Helper function to generate a valid video playlist
function generateVideoPlaylist(packetHandler) {
    let videoPlaylist = '#EXTM3U\n';
    videoPlaylist += '#EXT-X-VERSION:3\n';
    videoPlaylist += '#EXT-X-TARGETDURATION:4\n';
    videoPlaylist += '#EXT-X-MEDIA-SEQUENCE:0\n';
    
    // Add segment entries for video
    const videoSegments = Object.keys(packetHandler.buffer.video)
        .map(Number)
        .sort((a, b) => a - b);
    
    if (videoSegments.length === 0) {
        // Add a dummy segment if no segments are available yet
        videoPlaylist += '#EXTINF:4.0,\n';
        videoPlaylist += 'chunk_0_init.m4s\n';
    } else {
        for (let i = 0; i < videoSegments.length; i++) {
            const segId = videoSegments[i];
            videoPlaylist += '#EXTINF:4.0,\n';
            videoPlaylist += `chunk_0_${segId}.m4s\n`;
        }
        
        if (packetHandler.isDisconnected) {
            videoPlaylist += '#EXT-X-ENDLIST\n';
        }
    }
    
    // Register the updated playlist
    if (typeof window.registerManifestBlobUrl === 'function') {
        window.registerManifestBlobUrl('video.m3u8', videoPlaylist);
    }
    
    return videoPlaylist;
}

function initializeHLSPlayer(hlsUrl = '/vivoh.m3u8') {
    try {
        if (!window.Hls) {
            log("‚ùå HLS.js library not found!");
            return null;
        }
        
        if (!Hls.isSupported()) {
            log("‚ùå HLS.js is not supported in this browser");
            return null;
        }
        
        const videoElement = document.getElementById('videoElement');
        if (!videoElement) {
            log("‚ùå Video element not found");
            return null;
        }
        
        // Create HLS.js player with configuration specifically for TS segments
        const hls = new Hls({
            debug: true, // Turn on HLS.js built-in debugging
            enableWorker: true,
            lowLatencyMode: true,
            
            // Increase buffer size for TS segments
            maxBufferLength: 60,
            maxMaxBufferLength: 90,
            maxBufferSize: 120 * 1000 * 1000, // 120MB
            
            // More permissive fragment loading settings
            fragLoadingMaxRetry: 10,
            manifestLoadingMaxRetry: 10,
            levelLoadingMaxRetry: 10,
            fragLoadingRetryDelay: 1000,
            
            // More robust error handling
            appendErrorMaxRetry: 5,
            
            // Explicitly enable various recovery modes
            recoverMediaError: true,
            recoverNetworkError: true,
            
            // Don't stall on missing segments
            maxBufferHole: 2,
            maxStarvationDelay: 8000
        });

        // Add extra video element event listeners for better debugging
        if (videoElement) {
            videoElement.addEventListener('error', (e) => {
                log(`‚ùå Video element error: ${videoElement.error?.code}, ${videoElement.error?.message}`);
            });
            
            videoElement.addEventListener('canplay', () => {
                log(`‚úÖ Video can play`);
            });
            
            videoElement.addEventListener('playing', () => {
                log(`‚ñ∂Ô∏è Video started playing`);
                window.playerState = 'playing';
                updateUI();
            });
            
            videoElement.addEventListener('stalled', () => {
                log(`‚è∏Ô∏è Video playback stalled`);
                window.playerState = 'buffering';
                updateUI();
            });
            
            videoElement.addEventListener('waiting', () => {
                log(`‚è∏Ô∏è Video waiting for data`);
                window.playerState = 'buffering';
                updateUI();
            });
        }
        
        // Set up enhanced event monitoring
        enhanceHLSEventMonitoring(hls);
        
        // Attach to video element
        hls.attachMedia(videoElement);
        
        // Store the player globally
        window.player = hls;
        
        // In Hls.Events.MEDIA_ATTACHED, load the source
        hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            log(`üé¨ HLS.js attached to media element`);
            log(`üîó Loading source: ${hlsUrl}`);
            hls.loadSource(hlsUrl);
        });
        
        // Automatic playback after manifest is parsed (optional)
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
            log(`üìÑ Manifest parsed, attempting to play...`);
            // Uncomment to enable auto-play:
            // videoElement.play().catch(err => {
            //     log(`‚ùå Auto-play failed: ${err.message}`);
            // });
        });
        
        log(`‚úÖ HLS.js player initialized with URL: ${hlsUrl}`);
        
        return hls;
    } catch (error) {
        log(`‚ùå Error initializing HLS player: ${error.message}`);
        return null;
    }
}

function validateAndDebugManifest(manifestContent) {
    if (!manifestContent) {
        log(`‚ùå Empty manifest content!`);
        return false;
    }
    
    try {
        // Basic validation
        if (!manifestContent.includes('#EXTM3U')) {
            log(`‚ùå Invalid manifest - missing #EXTM3U header`);
            return false;
        }
        
        // Count segments
        const segmentCount = (manifestContent.match(/#EXTINF/g) || []).length;
        log(`üìã Manifest contains ${segmentCount} segments`);
        
        // Check for EXT-X-VERSION
        if (!manifestContent.includes('#EXT-X-VERSION')) {
            log(`‚ö†Ô∏è Manifest missing EXT-X-VERSION tag`);
        }
        
        // Check for media sequence
        if (!manifestContent.includes('#EXT-X-MEDIA-SEQUENCE')) {
            log(`‚ö†Ô∏è Manifest missing EXT-X-MEDIA-SEQUENCE tag`);
        }
        
        // Check if master playlist
        const isMasterPlaylist = manifestContent.includes('#EXT-X-STREAM-INF');
        
        if (isMasterPlaylist) {
            log(`üìã Manifest is a master playlist`);
            
            // Extract variant URLs
            const streamInfoPattern = /#EXT-X-STREAM-INF:([^\n]+)\n([^\n]+)/g;
            let match;
            let variantCount = 0;
            
            while ((match = streamInfoPattern.exec(manifestContent)) !== null) {
                variantCount++;
                const attributes = match[1];
                const variantUrl = match[2].trim();
                
                log(`üìã Found variant #${variantCount}: ${variantUrl}`);
                
                // For blob URLs, see if they're in the blobUrlMap
                if (variantUrl.startsWith('blob:') && window.blobUrlMap) {
                    if (window.blobUrlMap.has(variantUrl)) {
                        log(`‚úÖ Variant URL exists in blob map`);
                    } else {
                        log(`‚ùå Variant URL not found in blob map: ${variantUrl}`);
                    }
                }
            }
        } else {
            // Media playlist
            log(`üìã Manifest is a media playlist with ${segmentCount} segments`);
            
            // Extract segment URLs and durations
            const segmentPattern = /#EXTINF:([^,]+)(?:,([^\n]+))?\n([^\n]+)/g;
            let match;
            let totalDuration = 0;
            
            while ((match = segmentPattern.exec(manifestContent)) !== null) {
                const duration = parseFloat(match[1]);
                const title = match[2] || '';
                const segmentUrl = match[3].trim();
                
                totalDuration += duration;
                
                if (segmentUrl.includes('.ts')) {
                    log(`üìã Segment: ${segmentUrl}, duration=${duration.toFixed(3)}s${title ? `, title=${title}` : ''}`);
                    
                    // Check if this segment is already registered
                    if (window.blobUrlMap && !window.blobUrlMap.has(segmentUrl)) {
                        log(`‚ö†Ô∏è Segment not registered in blob map: ${segmentUrl}`);
                    }
                }
            }
            
            log(`üìã Total playlist duration: ${totalDuration.toFixed(3)}s`);
        }
        
        return true;
    } catch (error) {
        log(`‚ùå Error validating manifest: ${error.message}`);
        return false;
    }
}


// Function to set up packet handler callbacks
function setupPacketHandlerCallbacks() {
    if (!window.packetHandler) return;
    
    window.packetHandler.onHLSReady = (hlsUrl) => {
        log(`üìÑ HLS ready for playback: ${hlsUrl}`);
        
        if (!window.player) {
            initializeHLSPlayer(hlsUrl);
        } else {
            log(`üìÑ Player already exists, loading source: ${hlsUrl}`);
            window.player.loadSource(hlsUrl);
        }
    };
    
    log("‚úÖ Packet handler callbacks configured");
}

async function setupWebTransport(url) {
    try {
        window.disconnectionRequested = false;
        
        log(`üîç Setting up WebTransport with URL: ${url}`);
        
        // Clear any existing resources
        if (window.transport) {
            try { 
                window.transport.close(); 
            } catch (e) {
                log(`üîç Error closing existing transport: ${e.message}`);
            }
            window.transport = null;
        }
        
        // Initialize packet handler for HLS
        window.packetHandler = new WebTransportHLSPacketHandler();
        
        // Add a callback to validate the manifest when generated
        const originalGenerateHLS = window.packetHandler._generateHLSManifest;
        window.packetHandler._generateHLSManifest = function() {
            // Call the original function
            originalGenerateHLS.apply(this, arguments);
            
            // Now validate the generated manifest
            if (this.hlsData) {
                log(`üîç Validating master manifest:`);
                validateAndDebugManifest(this.hlsData);
                
                // Also validate video playlist
                const videoPlaylistContent = window.blobUrlMap.get(window.videoPlaylistUrl);
                if (videoPlaylistContent) {
                    log(`üîç Validating video playlist:`);
                    validateAndDebugManifest(videoPlaylistContent);
                }
            }
        };
        
        // Set up improved callbacks
        setupPacketHandlerCallbacks();
        
        // Set up XHR interception before connecting
        setupXHRInterception();
        
        // Add enhanced debugging
        enhanceXHRDebugging();
        
        // Connect to WebTransport 
        log(`üîó Connecting to WebTransport server: ${url}`);
        
        const createStartTime = Date.now();
        window.transport = new WebTransport(url);
        const createEndTime = Date.now();
        
        log(`üì° WebTransport object created in ${createEndTime - createStartTime}ms`);
        
        // Set up connection closed handler
        window.transport.closed.then(() => {
            log(`‚ÑπÔ∏è Connection closed normally`);
            if (!window.disconnectionRequested) {
                handleConnectionClosed();
            }
        }).catch((error) => {
            log(`‚ùå Connection closed with error: ${error.message}`);
            if (!window.disconnectionRequested) {
                handleConnectionClosed();
            }
        });
        
        // Listen for incoming streams
        listenToIncomingStreams(window.transport, window.packetHandler).catch(err => {
            log(`‚ùå Error in stream listener: ${err.message}`);
        });
        
        // Start status updates
        startStatusUpdates();
        
        // Update UI
        updateUI();
        
        log(`‚úÖ WebTransport setup completed successfully`);
        
        return window.packetHandler;
    } catch (error) {
        log(`‚ùå WebTransport error: ${error.message}`);
        updateUI();
        throw error;
    }
}

function setupImprovedPlayButton() {
    const playButton = document.getElementById('playButton');
    if (!playButton) return;
    
    playButton.addEventListener('click', function() {
        log(`üéÆ Play button clicked`);
        
        if (window.player) {
            const videoElement = document.getElementById('videoElement');
            
            if (!videoElement) {
                log(`‚ùå Video element not found!`);
                return;
            }
            
            log(`‚ñ∂Ô∏è Attempting to play video...`);
            
            // Extra error handling
            const playPromise = videoElement.play();
            
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        log(`‚úÖ Video playback started successfully`);
                        window.playerState = 'playing';
                        updateUI();
                    })
                    .catch(err => {
                        log(`‚ùå Error playing: ${err.name} - ${err.message}`);
                        
                        // Handle autoplay restrictions
                        if (err.name === 'NotAllowedError') {
                            log(`‚ö†Ô∏è Autoplay prevented by browser policy, user gesture required`);
                            alert('Your browser requires interaction before playback. Please click play again.');
                        }
                    });
            } else {
                log(`‚ö†Ô∏è Play promise undefined, browser may not support promises for media playback`);
            }
        } else {
            log(`‚ö†Ô∏è Player not initialized yet, initializing now...`);
            
            if (window.packetHandler && window.packetHandler.hlsUrl) {
                const player = initializeHLSPlayer(window.packetHandler.hlsUrl);
                
                if (player) {
                    log(`‚úÖ Player initialized on-demand, waiting for manifest to load before playing`);
                    
                    // Play after manifest is parsed
                    player.on(Hls.Events.MANIFEST_PARSED, () => {
                        log(`üìÑ Manifest parsed, attempting to play...`);
                        
                        const videoElement = document.getElementById('videoElement');
                        if (videoElement) {
                            videoElement.play().catch(err => {
                                log(`‚ùå Error playing after manifest parsed: ${err.message}`);
                            });
                        }
                    });
                }
            } else {
                log(`‚ùå No HLS URL available for playback`);
            }
        }
    });
    
    log(`‚úÖ Improved play button handler set up`);
}

function enhanceXHRDebugging() {
    // Only run this if XHR interception is already enabled
    if (!window.xhrInterceptionEnabled) return;
    
    log("üîç Enhancing XMLHttpRequest debugging for HLS.js");
    
    // Store the original open and send methods
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    // Add request/response timing tracking
    window.requestTimings = {};
    
    // Override open method with improved URL pattern detection
    XMLHttpRequest.prototype.open = function(method, url, async) {
        this._url = url;
        this._method = method;
        this._requestStartTime = Date.now();
        
        // Log all HLS-related requests for debugging
        if (typeof url === 'string' && (url.includes('.m3u8') || url.includes('.ts') || url.startsWith('blob:'))) {
            log(`üîç XHR ${method} Request: ${url}`);
        }
        
        // Add more detailed tracking for segment requests
        if (typeof url === 'string' && url.includes('.ts')) {
            this._isMediaSegment = true;
            
            // Extract the segment name from the URL
            const urlParts = url.split('/');
            const segmentName = urlParts[urlParts.length - 1];
            this._segmentName = segmentName;
            
            // Check if the segment is in our map
            if (window.blobUrlMap && window.blobUrlMap.has(segmentName)) {
                log(`‚úÖ Segment found in blob map: ${segmentName}`);
            } else {
                log(`‚ö†Ô∏è Segment NOT found in blob map: ${segmentName}`);
                
                // Debug available segments
                if (window.blobUrlMap) {
                    const segmentKeys = Array.from(window.blobUrlMap.keys())
                        .filter(k => k.includes('.ts'))
                        .slice(0, 5); // Show first 5 to avoid log spam
                    
                    log(`üîç Available segments (first 5): ${segmentKeys.join(', ')}${
                        window.blobUrlMap.size > 5 ? ` (and ${window.blobUrlMap.size - 5} more)` : ''
                    }`);
                }
            }
        }
        
        originalXHROpen.call(this, method, url, async !== false);
    };
    
    // Override send method to track responses
    XMLHttpRequest.prototype.send = function(body) {
        if (this._isMediaSegment || (typeof this._url === 'string' && this._url.includes('.m3u8'))) {
            const originalOnLoad = this.onload;
            const originalOnError = this.onerror;
            const url = this._url;
            const segmentName = this._segmentName;
            const startTime = this._requestStartTime;
            
            this.onload = function(e) {
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                if (this.status === 200) {
                    if (typeof url === 'string' && url.includes('.ts')) {
                        log(`‚úÖ Segment loaded: ${segmentName || url} (${duration}ms, size: ${this.response?.byteLength || 0} bytes)`);
                    } else if (typeof url === 'string' && url.includes('.m3u8')) {
                        log(`‚úÖ Manifest loaded: ${url} (${duration}ms)`);
                    }
                } else {
                    log(`‚ùå Failed to load: ${url} (${this.status})`);
                }
                
                if (originalOnLoad) originalOnLoad.call(this, e);
            };
            
            this.onerror = function(e) {
                log(`‚ùå Error loading: ${url}`);
                if (originalOnError) originalOnError.call(this, e);
            };
        }
        
        originalXHRSend.call(this, body);
    };
    
    log(`‚úÖ Enhanced XHR debugging completed`);
    return true;
}

function enhanceHLSEventMonitoring(hls) {
    if (!hls || !window.Hls) {
        log(`‚ùå Cannot enhance HLS monitoring - player not initialized`);
        return false;
    }
    
    log(`üîç Setting up detailed HLS.js event monitoring`);
    
    // Track buffer state
    window.hlsBufferState = {
        audio: {
            buffered: [],
            appended: 0
        },
        video: {
            buffered: [],
            appended: 0
        },
        lastUpdate: Date.now()
    };
    
    // Monitor fragment loading
    hls.on(Hls.Events.FRAG_LOADING, (event, data) => {
        log(`üîÑ Loading fragment: level=${data.frag.level}, sn=${data.frag.sn}, type=${data.frag.type}, url=${data.frag.url}`);
    });
    
    // Monitor successful loading
    hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
        log(`‚úÖ Fragment loaded: level=${data.frag.level}, sn=${data.frag.sn}, type=${data.frag.type}, size=${data.frag.loaded} bytes`);
    });
    
    // Monitor fragment parse success
    hls.on(Hls.Events.FRAG_PARSING_DATA, (event, data) => {
        const type = data.type;
        window.hlsBufferState[type].appended++;
        log(`‚öôÔ∏è Parsed fragment data: type=${type}, pts=${data.startPTS.toFixed(2)}-${data.endPTS.toFixed(2)}, duration=${(data.endPTS - data.startPTS).toFixed(2)}s`);
        
        // Update UI to show that fragments are being processed
        const bufferStatus = document.getElementById('bufferStatus');
        if (bufferStatus) {
            const videoCount = window.hlsBufferState.video.appended;
            const audioCount = window.hlsBufferState.audio.appended;
            bufferStatus.textContent = `${videoCount + audioCount} fragments`;
        }
    });
    
    // Monitor media attaching
    hls.on(Hls.Events.MEDIA_ATTACHED, (event, data) => {
        log(`üì± Media element attached to HLS.js`);
        
        // Update player status
        window.playerState = 'attached';
        updateUI();
    });
    
    // Monitor media detaching
    hls.on(Hls.Events.MEDIA_DETACHED, (event, data) => {
        log(`üì± Media element detached from HLS.js`);
        
        // Update player status
        window.playerState = 'detached';
        updateUI();
    });
    
    // Monitor buffer appending
    hls.on(Hls.Events.BUFFER_APPENDING, (event, data) => {
        log(`üìã Appending to ${data.type} buffer: ${data.data.byteLength} bytes`);
    });
    
    // Monitor buffer appended
    hls.on(Hls.Events.BUFFER_APPENDED, (event, data) => {
        log(`üìã Appended to ${data.type} buffer`);
    });
    
    // Enhanced error monitoring
    hls.on(Hls.Events.ERROR, (event, data) => {
        const errorTypes = {
            [Hls.ErrorTypes.NETWORK_ERROR]: 'Network',
            [Hls.ErrorTypes.MEDIA_ERROR]: 'Media',
            [Hls.ErrorTypes.MUX_ERROR]: 'Multiplexing',
            [Hls.ErrorTypes.OTHER_ERROR]: 'Other'
        };
        
        const errorType = errorTypes[data.type] || data.type;
        const errorDetails = data.details || 'unknown';
        const isFatal = !!data.fatal;
        
        log(`‚ùå ${isFatal ? 'FATAL ' : ''}${errorType} ERROR: ${errorDetails}`);
        
        if (data.response) {
            log(`‚ùå Response: status=${data.response.code}, url=${data.response.url}`);
        }
        
        // Add more details based on error type
        if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
            log(`‚ùå Network error context: ${JSON.stringify({
                url: data.context?.url,
                status: data.context?.status,
                networkDetails: data.networkDetails?.status
            })}`);
        } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
            log(`‚ùå Media error context: ${data.context || 'No context'}`);
        }
        
        if (isFatal) {
            log(`‚ö†Ô∏è Attempting to recover from fatal error...`);
            
            if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                hls.startLoad();
                log(`üîÑ Restarting network loading...`);
            } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                hls.recoverMediaError();
                log(`üîÑ Attempting media error recovery...`);
            }
        }
    });
    
    // Monitor level loading
    hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {
        log(`üìù Level ${data.level} loaded: ${data.details.fragments.length} fragments, duration=${data.details.totalduration.toFixed(2)}s`);
    });
    
    // Monitor manifest loading
    hls.on(Hls.Events.MANIFEST_LOADED, (event, data) => {
        log(`üìù Manifest loaded: ${data.levels.length} quality levels`);
    });
    
    // Monitor manifest parsed
    hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
        log(`üìù Manifest parsed: ${data.levels.length} quality levels`);
        
        // Update player status
        window.playerState = 'ready';
        updateUI();
        
        // Enable play button
        const playButton = document.getElementById('playButton');
        if (playButton) {
            playButton.disabled = false;
        }
    });
    
    // Media events
    const video = hls.media;
    if (video) {
        ['loadstart', 'play', 'playing', 'pause', 'seeking', 'seeked', 'waiting', 'stalled', 'ended', 'error'].forEach(eventName => {
            video.addEventListener(eventName, (e) => {
                log(`üé¨ Video event: ${eventName}`);
                
                // Update player status based on video state
                if (eventName === 'playing') {
                    window.playerState = 'playing';
                } else if (eventName === 'pause') {
                    window.playerState = 'paused';
                } else if (eventName === 'waiting' || eventName === 'stalled') {
                    window.playerState = 'buffering';
                } else if (eventName === 'ended') {
                    window.playerState = 'ended';
                } else if (eventName === 'error') {
                    window.playerState = 'error';
                    log(`‚ùå Video error: ${video.error?.code}, ${video.error?.message}`);
                }
                
                updateUI();
            });
        });
    }
    
    // Set up a timer to periodically check buffer state
    if (window.bufferStateInterval) {
        clearInterval(window.bufferStateInterval);
    }
    
    window.bufferStateInterval = setInterval(() => {
        if (!hls || !hls.media) return;
        
        const video = hls.media;
        const buffered = [];
        
        for (let i = 0; i < video.buffered.length; i++) {
            buffered.push({
                start: video.buffered.start(i),
                end: video.buffered.end(i)
            });
        }
        
        const currentTime = video.currentTime;
        const bufferedAhead = getBufferedAheadOf(video.buffered, currentTime);
        
        log(`üìä Buffer state: currentTime=${currentTime.toFixed(2)}s, bufferedAhead=${bufferedAhead.toFixed(2)}s, ranges=${buffered.length}`);
        
        // Update fragments count in UI
        const bufferStatus = document.getElementById('bufferStatus');
        if (bufferStatus) {
            const fragmentCount = window.hlsBufferState.video.appended + window.hlsBufferState.audio.appended;
            bufferStatus.textContent = `${fragmentCount} fragments`;
        }
    }, 5000);
    
    log(`‚úÖ HLS.js event monitoring setup completed`);
    return true;
}

// Helper function to get amount of media buffered ahead of current position
function getBufferedAheadOf(buffered, position) {
    for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        
        if (position >= start && position < end) {
            return end - position;
        }
    }
    return 0;
}

/**
 * Simple logging function that outputs to both console and UI
 */
 function log(message) {
    const logEl = document.getElementById('logcatbox');
    if (!logEl) {
        console.log(message);
        return;
    }
    
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    
    // Handle multi-line messages (like M3U8 content)
    if (message.includes('\n')) {
        const lines = message.split('\n');
        const firstLine = `[${time}] ${lines[0]}`;
        logEl.value += firstLine + '\n';
        
        // Indent subsequent lines for better readability
        for (let i = 1; i < lines.length; i++) {
            logEl.value += `        ${lines[i]}\n`;
        }
    } else {
        const formattedMessage = `[${time}] ${message}`;
        logEl.value += formattedMessage + '\n';
    }
    
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}

/**
 * Listen for incoming streams and process WebTransport data
 */
 async function listenToIncomingStreams(transport, packetHandler) {
    // Reset stream counter
    window.streamCounter = 0;
    
    try {
        log("üéß Listening for incoming streams...");
        
        // Handle readable streams from the server
        const reader = transport.incomingUnidirectionalStreams.getReader();
        
        // Track active readers for cleanup
        window.activeReaders = [];
        
        while (!window.disconnectionRequested) {
            const { value: stream, done } = await reader.read();
            
            if (done) {
                log("üì¢ Server finished sending streams");
                break;
            }
            
            // Increment stream counter
            window.streamCounter++;
            
            // Handle this specific stream
            handleIncomingStream(stream, packetHandler);
        }
    } catch (error) {
        log(`‚ùå Error in stream listener: ${error.message}`);
        if (!window.disconnectionRequested) {
            // Only show error message if not intentionally disconnected
            handleConnectionClosed();
        }
    }
}

/**
 * Process an individual incoming stream
 */
async function handleIncomingStream(stream, packetHandler) {
    const reader = stream.getReader();
    window.activeReaders.push(reader);
    
    try {
        log(`üì• Processing incoming stream #${window.streamCounter}`);
        
        while (!window.disconnectionRequested) {
            const { value, done } = await reader.read();
            
            if (done) {
                log(`üì§ Stream #${window.streamCounter} ended`);
                break;
            }
            
            if (value && value.byteLength > 0) {
                // Process WebTransport media packet
                packetHandler.processWMPPacket(value);
                
                // Update UI counter
                document.getElementById('packetCounter').textContent = 
                    packetHandler.packetsReceived.toString();
            }
        }
    } catch (error) {
        log(`‚ùå Error reading stream: ${error.message}`);
    } finally {
        try {
            reader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
        
        // Remove from active readers list
        const index = window.activeReaders.indexOf(reader);
        if (index !== -1) {
            window.activeReaders.splice(index, 1);
        }
    }
}

/**
 * Handle connection close events
 */
function handleConnectionClosed() {
    log("üõë Connection closed");
    
    // Update UI
    document.getElementById('connectionStatus').textContent = "Disconnected";
    document.getElementById('connectionStatus').className = "status-badge status-disconnected";
    
    // Re-enable connect button
    document.getElementById('connectButton').disabled = false;
    document.getElementById('playButton').disabled = true;
    document.getElementById('disconnectButton').disabled = true;
    
    // Stop status updates
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
        window.statusInterval = null;
    }
    
    // Clean up readers
    window.activeReaders.forEach(reader => {
        try { reader.releaseLock(); } catch (e) { /* Ignore */ }
    });
    window.activeReaders = [];
    
    // Stop video playback
    if (window.player) {
        try {
            window.player.destroy();
        } catch (e) {
            log(`‚ö†Ô∏è Error destroying player: ${e.message}`);
        }
        window.player = null;
    }
    
    // Reset packet handler
    if (window.packetHandler) {
        try {
            window.packetHandler.disconnect();
        } catch (e) {
            log(`‚ö†Ô∏è Error disconnecting packet handler: ${e.message}`);
        }
        window.packetHandler = null;
    }
    
    // Reset transport
    if (window.transport) {
        try {
            window.transport.close();
        } catch (e) {
            log(`‚ö†Ô∏è Error closing transport: ${e.message}`);
        }
        window.transport = null;
    }
    
    window.playerState = 'idle';
    updateUI();
}

/**
 * Update UI elements based on current state
 */
function updateUI() {
    // Update connection status
    const connectionStatus = document.getElementById('connectionStatus');
    connectionStatus.textContent = window.transport ? "Connected" : "Disconnected";
    connectionStatus.className = window.transport ? 
        "status-badge status-connected" : "status-badge status-disconnected";
    
    // Update button states
    document.getElementById('connectButton').disabled = !!window.transport;
    document.getElementById('disconnectButton').disabled = !window.transport;
    
    // Update player status
    const playerStatus = document.getElementById('playerStatus');
    switch (window.playerState) {
        case 'playing':
            playerStatus.textContent = "Playing";
            playerStatus.className = "status-badge status-connected";
            break;
        case 'paused':
            playerStatus.textContent = "Paused";
            playerStatus.className = "status-badge";
            break;
        case 'buffering':
            playerStatus.textContent = "Buffering";
            playerStatus.className = "status-badge status-buffering";
            break;
        case 'error':
            playerStatus.textContent = "Error";
            playerStatus.className = "status-badge status-disconnected";
            break;
        case 'ready':
            playerStatus.textContent = "Ready";
            playerStatus.className = "status-badge";
            break;
        default:
            playerStatus.textContent = "Idle";
            playerStatus.className = "status-badge";
    }
    
    // Update buffer status if available
    if (window.packetHandler) {
        const stats = window.packetHandler.getStats();
        document.getElementById('bufferStatus').textContent = 
            `${stats.fragmentsAvailable} fragments`;
    } else {
        document.getElementById('bufferStatus').textContent = "0 fragments";
    }
    
    // Update stream counter
    document.getElementById('streamCounter').textContent = 
        window.streamCounter ? window.streamCounter.toString() : "0";
    
    // Update packet counter
    if (window.packetHandler) {
        document.getElementById('packetCounter').textContent = 
            window.packetHandler.packetsReceived.toString();
    } else {
        document.getElementById('packetCounter').textContent = "0";
    }
}

/**
 * Start periodic status updates
 */
function startStatusUpdates() {
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
    }
    
    window.statusInterval = setInterval(() => {
        updateUI();
    }, 1000);
}

// Set up event listeners for buttons
document.addEventListener('DOMContentLoaded', function() {
    // Connect button
    document.getElementById('connectButton').addEventListener('click', async function() {
        try {
            const url = document.getElementById('wtUrl').value;
            
            if (!url || !url.startsWith('https://')) {
                alert('Please enter a valid HTTPS WebTransport URL');
                return;
            }
            
            // Disable connect button while connecting
            this.disabled = true;
            log(`üîó Connecting to ${url}...`);
            
            // Update UI to show connection in progress
            document.getElementById('connectionStatus').textContent = "Connecting...";
            
            // Attempt to setup WebTransport connection
            await setupWebTransport(url);
            
            // Update connection status
            document.getElementById('connectionStatus').textContent = "Connected";
            document.getElementById('connectionStatus').className = "status-badge status-connected";
            
            // Enable disconnect button
            document.getElementById('disconnectButton').disabled = false;
            
        } catch (error) {
            log(`‚ùå Connection failed: ${error.message}`);
            this.disabled = false;
            document.getElementById('connectionStatus').textContent = "Failed";
            document.getElementById('connectionStatus').className = "status-badge status-disconnected";
        }
    });
    
    // Play button
    document.getElementById('playButton').addEventListener('click', function() {
        if (window.player) {
            const videoElement = document.getElementById('videoElement');
            videoElement.play().catch(err => {
                log(`‚ùå Error playing: ${err.message}`);
            });
            log(`‚ñ∂Ô∏è Playing video`);
        } else {
            log(`‚ö†Ô∏è Player not initialized yet`);
        }
    });
    
    // Disconnect button
    document.getElementById('disconnectButton').addEventListener('click', function() {
        window.disconnectionRequested = true;
        log(`üîå Disconnecting...`);
        
        handleConnectionClosed();
    });
    
    // Initialize UI
    updateUI();
    setupImprovedPlayButton();
    log(`üöÄ Player initialized and ready`);
});
    </script>
</body>
</html>